diff --git a/STM32F1/boards.txt b/STM32F1/boards.txt
index d9be235..89d5d72 100644
--- a/STM32F1/boards.txt
+++ b/STM32F1/boards.txt
@@ -1088,3 +1088,191 @@ STM32VLD.menu.opt.ogstd.build.flags.optimize=-Og
 STM32VLD.menu.opt.ogstd.build.flags.ldspecs=
 
 ################################################################################
+
+###################### Generic GD32F303C ########################################
+
+genericGD32F303C.name=Generic GD32F303C series
+genericGD32F303C.vid.0=0x1EAF
+genericGD32F303C.pid.0=0x0004
+genericGD32F303C.build.variant=generic_gd32f303c
+genericGD32F303C.build.vect=VECT_TAB_ADDR=0x8000000
+genericGD32F303C.build.core=maple
+genericGD32F303C.build.board=GENERIC_GD32F303C
+genericGD32F303C.build.error_led_port=GPIOC
+genericGD32F303C.build.error_led_pin=13
+genericGD32F303C.upload.use_1200bps_touch=false
+genericGD32F303C.upload.file_type=bin
+genericGD32F303C.upload.auto_reset=true
+genericGD32F303C.upload.tool=maple_upload
+genericGD32F303C.upload.protocol=maple_dfu
+
+## GD32F303C8 -------------------------
+genericGD32F303C.menu.device_variant.GD32F303C8=GD32F303C8 (48 RAM. 256 Flash)
+genericGD32F303C.menu.device_variant.GD32F303C8.build.cpu_flags=-DMCU_GD32F303C8
+genericGD32F303C.menu.device_variant.GD32F303C8.build.ldscript=ld/jtag_c8.ld
+genericGD32F303C.menu.device_variant.GD32F303C8.upload.maximum_size=65536
+genericGD32F303C.menu.device_variant.GD32F303C8.upload.maximum_data_size=20480
+
+#---------------------------- UPLOAD METHODS ---------------------------
+
+genericGD32F303C.menu.upload_method.DFUUploadMethod=STM32duino bootloader
+genericGD32F303C.menu.upload_method.DFUUploadMethod.upload.protocol=maple_dfu
+genericGD32F303C.menu.upload_method.DFUUploadMethod.upload.tool=maple_upload
+genericGD32F303C.menu.upload_method.DFUUploadMethod.build.upload_flags=-DSERIAL_USB -DGENERIC_BOOTLOADER
+genericGD32F303C.menu.upload_method.DFUUploadMethod.build.vect=VECT_TAB_ADDR=0x8002000
+genericGD32F303C.menu.upload_method.DFUUploadMethod.build.ldscript=ld/bootloader_20.ld
+genericGD32F303C.menu.upload_method.DFUUploadMethod.upload.usbID=1EAF:0003
+genericGD32F303C.menu.upload_method.DFUUploadMethod.upload.altID=2
+
+genericGD32F303C.menu.upload_method.serialMethod=Serial
+genericGD32F303C.menu.upload_method.serialMethod.upload.protocol=maple_serial
+genericGD32F303C.menu.upload_method.serialMethod.upload.tool=serial_upload
+genericGD32F303C.menu.upload_method.serialMethod.build.upload_flags=-DCONFIG_MAPLE_MINI_NO_DISABLE_DEBUG
+
+genericGD32F303C.menu.upload_method.STLinkMethod=STLink
+genericGD32F303C.menu.upload_method.STLinkMethod.upload.protocol=STLink
+genericGD32F303C.menu.upload_method.STLinkMethod.upload.tool=stlink_upload
+genericGD32F303C.menu.upload_method.STLinkMethod.build.upload_flags=-DCONFIG_MAPLE_MINI_NO_DISABLE_DEBUG=1 -DSERIAL_USB -DGENERIC_BOOTLOADER
+
+genericGD32F303C.menu.upload_method.BMPMethod=BMP (Black Magic Probe)
+genericGD32F303C.menu.upload_method.BMPMethod.upload.protocol=gdb_bmp
+genericGD32F303C.menu.upload_method.BMPMethod.upload.tool=bmp_upload
+genericGD32F303C.menu.upload_method.BMPMethod.build.upload_flags=-DCONFIG_MAPLE_MINI_NO_DISABLE_DEBUG
+
+genericGD32F303C.menu.upload_method.jlinkMethod=JLink
+genericGD32F303C.menu.upload_method.jlinkMethod.upload.protocol=jlink
+genericGD32F303C.menu.upload_method.jlinkMethod.upload.tool=jlink_upload
+genericGD32F303C.menu.upload_method.jlinkMethod.build.upload_flags=-DCONFIG_MAPLE_MINI_NO_DISABLE_DEBUG=1 -DSERIAL_USB -DGENERIC_BOOTLOADER 
+
+genericGD32F303C.menu.upload_method.HIDUploadMethod=HID bootloader 2.0
+genericGD32F303C.menu.upload_method.HIDUploadMethod.upload.tool=hid_upload
+genericGD32F303C.menu.upload_method.HIDUploadMethod.build.upload_flags=-DSERIAL_USB -DGENERIC_BOOTLOADER
+genericGD32F303C.menu.upload_method.HIDUploadMethod.build.vect=VECT_TAB_ADDR=0x8001000
+genericGD32F303C.menu.upload_method.HIDUploadMethod.build.ldscript=ld/hid_bootloader.ld
+
+#-- CPU Clock frequency
+genericGD32F303C.menu.cpu_speed.speed_96mhz=96Mhz (Normal)
+genericGD32F303C.menu.cpu_speed.speed_96mhz.build.f_cpu=96000000L
+
+genericGD32F303C.menu.cpu_speed.speed_120mhz=120Mhz (Normal)
+genericGD32F303C.menu.cpu_speed.speed_120mhz.build.f_cpu=120000000L
+
+genericGD32F303C.menu.cpu_speed.speed_72mhz=72Mhz (Normal)
+genericGD32F303C.menu.cpu_speed.speed_72mhz.build.f_cpu=72000000L
+
+genericGD32F303C.menu.cpu_speed.speed_48mhz=48Mhz (Slow - with USB)
+genericGD32F303C.menu.cpu_speed.speed_48mhz.build.f_cpu=48000000L
+
+genericGD32F303C.menu.cpu_speed.speed_128mhz=Overclocked 128Mhz NO USB SERIAL. MANUAL RESET NEEDED TO UPLOAD
+genericGD32F303C.menu.cpu_speed.speed_128mhz.build.f_cpu=128000000L
+
+#-- Optimizations
+genericGD32F303C.menu.opt.osstd=Smallest (default)
+genericGD32F303C.menu.opt.o1std=Fast (-O1)
+genericGD32F303C.menu.opt.o1std.build.flags.optimize=-O1
+genericGD32F303C.menu.opt.o1std.build.flags.ldspecs=
+genericGD32F303C.menu.opt.o2std=Faster (-O2)
+genericGD32F303C.menu.opt.o2std.build.flags.optimize=-O2
+genericGD32F303C.menu.opt.o2std.build.flags.ldspecs=
+genericGD32F303C.menu.opt.o3std=Fastest (-O3)
+genericGD32F303C.menu.opt.o3std.build.flags.optimize=-O3
+genericGD32F303C.menu.opt.o3std.build.flags.ldspecs=
+genericGD32F303C.menu.opt.ogstd=Debug (-g)
+genericGD32F303C.menu.opt.ogstd.build.flags.optimize=-Og
+genericGD32F303C.menu.opt.ogstd.build.flags.ldspecs=
+
+###############################################################"
+## GD32F103C
+###############################################################"
+
+genericGD32F103C.name=Generic GD32F103C series
+genericGD32F103C.vid.0=0x1EAF
+genericGD32F103C.pid.0=0x0004
+genericGD32F103C.build.variant=generic_gd32f103c2
+genericGD32F103C.build.vect=VECT_TAB_ADDR=0x8000000
+genericGD32F103C.build.core=maple
+genericGD32F103C.build.board=GENERIC_GD32F103C
+genericGD32F103C.build.error_led_port=GPIOC
+genericGD32F103C.build.error_led_pin=13
+genericGD32F103C.upload.use_1200bps_touch=false
+genericGD32F103C.upload.file_type=bin
+genericGD32F103C.upload.auto_reset=true
+genericGD32F103C.upload.tool=maple_upload
+genericGD32F103C.upload.protocol=maple_dfu
+
+## GD32F103C8 -------------------------
+genericGD32F103C.menu.device_variant.GD32F103C8=GD32F103C8 (20 RAM. 64 Flash)
+genericGD32F103C.menu.device_variant.GD32F103C8.build.cpu_flags=-DMCU_GD32F103C8
+genericGD32F103C.menu.device_variant.GD32F103C8.build.ldscript=ld/jtag_c8.ld
+genericGD32F103C.menu.device_variant.GD32F103C8.upload.maximum_size=65536
+genericGD32F103C.menu.device_variant.GD32F103C8.upload.maximum_data_size=20480
+
+#---------------------------- UPLOAD METHODS ---------------------------
+
+genericGD32F103C.menu.upload_method.DFUUploadMethod=STM32duino bootloader
+genericGD32F103C.menu.upload_method.DFUUploadMethod.upload.protocol=maple_dfu
+genericGD32F103C.menu.upload_method.DFUUploadMethod.upload.tool=maple_upload
+genericGD32F103C.menu.upload_method.DFUUploadMethod.build.upload_flags=-DSERIAL_USB -DGENERIC_BOOTLOADER
+genericGD32F103C.menu.upload_method.DFUUploadMethod.build.vect=VECT_TAB_ADDR=0x8002000
+genericGD32F103C.menu.upload_method.DFUUploadMethod.build.ldscript=ld/bootloader_20.ld
+genericGD32F103C.menu.upload_method.DFUUploadMethod.upload.usbID=1EAF:0003
+genericGD32F103C.menu.upload_method.DFUUploadMethod.upload.altID=2
+
+genericGD32F103C.menu.upload_method.serialMethod=Serial
+genericGD32F103C.menu.upload_method.serialMethod.upload.protocol=maple_serial
+genericGD32F103C.menu.upload_method.serialMethod.upload.tool=serial_upload
+genericGD32F103C.menu.upload_method.serialMethod.build.upload_flags=-DCONFIG_MAPLE_MINI_NO_DISABLE_DEBUG
+
+genericGD32F103C.menu.upload_method.STLinkMethod=STLink
+genericGD32F103C.menu.upload_method.STLinkMethod.upload.protocol=STLink
+genericGD32F103C.menu.upload_method.STLinkMethod.upload.tool=stlink_upload
+genericGD32F103C.menu.upload_method.STLinkMethod.build.upload_flags=-DCONFIG_MAPLE_MINI_NO_DISABLE_DEBUG=1 -DSERIAL_USB -DGENERIC_BOOTLOADER
+
+genericGD32F103C.menu.upload_method.BMPMethod=BMP (Black Magic Probe)
+genericGD32F103C.menu.upload_method.BMPMethod.upload.protocol=gdb_bmp
+genericGD32F103C.menu.upload_method.BMPMethod.upload.tool=bmp_upload
+genericGD32F103C.menu.upload_method.BMPMethod.build.upload_flags=-DCONFIG_MAPLE_MINI_NO_DISABLE_DEBUG
+
+genericGD32F103C.menu.upload_method.jlinkMethod=JLink
+genericGD32F103C.menu.upload_method.jlinkMethod.upload.protocol=jlink
+genericGD32F103C.menu.upload_method.jlinkMethod.upload.tool=jlink_upload
+genericGD32F103C.menu.upload_method.jlinkMethod.build.upload_flags=-DCONFIG_MAPLE_MINI_NO_DISABLE_DEBUG=1 -DSERIAL_USB -DGENERIC_BOOTLOADER 
+
+genericGD32F103C.menu.upload_method.HIDUploadMethod=HID bootloader 2.0
+genericGD32F103C.menu.upload_method.HIDUploadMethod.upload.tool=hid_upload
+genericGD32F103C.menu.upload_method.HIDUploadMethod.build.upload_flags=-DSERIAL_USB -DGENERIC_BOOTLOADER
+genericGD32F103C.menu.upload_method.HIDUploadMethod.build.vect=VECT_TAB_ADDR=0x8001000
+genericGD32F103C.menu.upload_method.HIDUploadMethod.build.ldscript=ld/hid_bootloader.ld
+
+#-- CPU Clock frequency
+genericGD32F103C.menu.cpu_speed.speed_96mhz=96Mhz (Normal)
+genericGD32F103C.menu.cpu_speed.speed_96mhz.build.f_cpu=96000000L
+
+genericGD32F103C.menu.cpu_speed.speed_120mhz=120Mhz (Normal)
+genericGD32F103C.menu.cpu_speed.speed_120mhz.build.f_cpu=120000000L
+
+genericGD32F103C.menu.cpu_speed.speed_72mhz=72Mhz (Normal)
+genericGD32F103C.menu.cpu_speed.speed_72mhz.build.f_cpu=72000000L
+
+genericGD32F103C.menu.cpu_speed.speed_48mhz=48Mhz (Slow - with USB)
+genericGD32F103C.menu.cpu_speed.speed_48mhz.build.f_cpu=48000000L
+
+genericGD32F103C.menu.cpu_speed.speed_128mhz=Overclocked 128Mhz NO USB SERIAL. MANUAL RESET NEEDED TO UPLOAD
+genericGD32F103C.menu.cpu_speed.speed_128mhz.build.f_cpu=128000000L
+
+#-- Optimizations
+genericGD32F103C.menu.opt.osstd=Smallest (default)
+genericGD32F103C.menu.opt.o1std=Fast (-O1)
+genericGD32F103C.menu.opt.o1std.build.flags.optimize=-O1
+genericGD32F103C.menu.opt.o1std.build.flags.ldspecs=
+genericGD32F103C.menu.opt.o2std=Faster (-O2)
+genericGD32F103C.menu.opt.o2std.build.flags.optimize=-O2
+genericGD32F103C.menu.opt.o2std.build.flags.ldspecs=
+genericGD32F103C.menu.opt.o3std=Fastest (-O3)
+genericGD32F103C.menu.opt.o3std.build.flags.optimize=-O3
+genericGD32F103C.menu.opt.o3std.build.flags.ldspecs=
+genericGD32F103C.menu.opt.ogstd=Debug (-g)
+genericGD32F103C.menu.opt.ogstd.build.flags.optimize=-Og
+genericGD32F103C.menu.opt.ogstd.build.flags.ldspecs=
+
+
diff --git a/STM32F1/system/libmaple/stm32f1/include/series/stm32.h b/STM32F1/system/libmaple/stm32f1/include/series/stm32.h
index e656f3e..085dc7d 100644
--- a/STM32F1/system/libmaple/stm32f1/include/series/stm32.h
+++ b/STM32F1/system/libmaple/stm32f1/include/series/stm32.h
@@ -172,6 +172,23 @@ extern "C" {
 #   define STM32_SRAM_END               ((void*)0x20002000)
 #   define STM32_MEDIUM_DENSITY
 
+#elif defined(MCU_GD32F303C8)
+#   define STM32_NR_GPIO_PORTS          3
+#   define STM32_SRAM_END               ((void*)0x2000C000)
+#   define NR_GPIO_PORTS                STM32_NR_GPIO_PORTS
+#   define STM32_F1_LINE                STM32_F1_LINE_PERFORMANCE
+#   define STM32_MEDIUM_DENSITY
+
+
+#elif defined(MCU_GD32F103C8)
+#   define STM32_NR_GPIO_PORTS          3
+#   define STM32_SRAM_END               ((void*)0x2000C000)
+#   define NR_GPIO_PORTS                STM32_NR_GPIO_PORTS
+#   define STM32_F1_LINE                STM32_F1_LINE_PERFORMANCE
+#   define STM32_MEDIUM_DENSITY
+
+
+
 #else
 #warning "Unsupported or unspecified STM32F1 MCU."
 #endif
diff --git a/STM32F1/variants/generic_gd32f103c2/board.cpp b/STM32F1/variants/generic_gd32f103c2/board.cpp
new file mode 100644
index 0000000..900e118
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f103c2/board.cpp
@@ -0,0 +1,129 @@
+/******************************************************************************
+ * The MIT License
+ *
+ * Copyright (c) 2011 LeafLabs, LLC.
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation
+ * files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy,
+ * modify, merge, publish, distribute, sublicense, and/or sell copies
+ * of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *****************************************************************************/
+
+/**
+ * &file   wirish/boards/maple_mini/board.cpp
+ * &author Marti Bolivar <mbolivar&leaflabs.com>
+ * &brief  Maple Mini board file.
+ */
+
+#include <board/board.h>
+
+#include <libmaple/gpio.h>
+#include <libmaple/timer.h>
+
+/* Roger Clark. Added next to includes for changes to Serial */
+#include <libmaple/usart.h>
+#include <HardwareSerial.h>
+
+#include <wirish_debug.h>
+#include <wirish_types.h>
+
+/* Since we want the Serial Wire/JTAG pins as GPIOs, disable both SW
+ * and JTAG debug support, unless configured otherwise. */
+void boardInit(void) {
+#ifndef CONFIG_MAPLE_MINI_NO_DISABLE_DEBUG
+    disableDebugPorts();
+#endif
+}
+
+// Note. See the enum of pin names in board.h
+
+extern const stm32_pin_info PIN_MAP[BOARD_NR_GPIO_PINS] = {
+
+
+    {&gpioa, &timer2, &adc1,  0, 1,    0}, /* PA0 */
+    {&gpioa, &timer2, &adc1,  1, 2,    1}, /* PA1 */
+    {&gpioa, &timer2, &adc1,  2, 3,    2}, /* PA2 */	
+    {&gpioa, &timer2, &adc1,  3, 4,    3}, /* PA3 */
+    {&gpioa,   NULL, &adc1,  4, 0,    4}, /* PA4 */
+    {&gpioa,   NULL, &adc1,  5, 0,    5}, /* PA5 */
+    {&gpioa, &timer3, &adc1,  6, 1,    6}, /* PA6 */
+    {&gpioa, &timer3, &adc1,  7, 2,    7}, /* PA7 */
+    {&gpioa, &timer1, NULL,  8, 1, ADCx}, /* PA8 */	
+    {&gpioa, &timer1, NULL,  9, 2, ADCx}, /* PA9 */	
+    {&gpioa, &timer1, NULL, 10, 3, ADCx}, /* PA10 */
+    {&gpioa, &timer1, NULL, 11, 4, ADCx}, /* PA11 */
+    {&gpioa,   NULL, NULL, 12, 0, ADCx}, /* PA12 */	
+    {&gpioa,   NULL, NULL, 13, 0, ADCx}, /* PA13 */	
+    {&gpioa,   NULL, NULL, 14, 0, ADCx}, /* PA14 */
+    {&gpioa,   NULL, NULL, 15, 0, ADCx}, /* PA15 */
+	
+    {&gpiob, &timer3, &adc1,  0, 3,    8}, /* PB0 */	
+    {&gpiob, &timer3, &adc1,  1, 4,    9}, /* PB1 */
+    {&gpiob,   NULL, NULL,  2, 0, ADCx}, /* PB2 */
+    {&gpiob,   NULL, NULL,  3, 0, ADCx}, /* PB3 */
+    {&gpiob,   NULL, NULL,  4, 0, ADCx}, /* PB4 */
+    {&gpiob,   NULL, NULL,  5, 0, ADCx}, /* PB5 */
+    {&gpiob, &timer4, NULL,  6, 1, ADCx}, /* PB6 */
+    {&gpiob, &timer4, NULL,  7, 2, ADCx}, /* PB7 */	
+    {&gpiob, &timer4, NULL,  8, 3, ADCx}, /* PB8 */	
+    {&gpiob, &timer4, NULL,  9, 4, ADCx}, /* PB9 */	
+    {&gpiob,   NULL, NULL, 10, 0, ADCx}, /* PB10 */	
+    {&gpiob,   NULL, NULL, 11, 0, ADCx}, /* PB11 */
+    {&gpiob,   NULL, NULL, 12, 0, ADCx}, /* PB12 */
+    {&gpiob,   NULL, NULL, 13, 0, ADCx}, /* PB13 */
+    {&gpiob,   NULL, NULL, 14, 0, ADCx}, /* PB14 */
+    {&gpiob,   NULL, NULL, 15, 0, ADCx}, /* PB15 */
+
+    {&gpioc,   NULL, NULL, 13, 0, ADCx}, /* PC13 */	
+    {&gpioc,   NULL, NULL, 14, 0, ADCx}, /* PC14 */
+    {&gpioc,   NULL, NULL, 15, 0, ADCx}, /* PC15 */
+
+
+
+};
+
+extern const uint8 boardPWMPins[BOARD_NR_PWM_PINS] __FLASH__ = {
+    PB0, PA7, PA6, PA3, PA2, PA1, PA0, PB7, PB6, PA10, PA9, PA8
+};
+
+extern const uint8 boardADCPins[BOARD_NR_ADC_PINS] __FLASH__ = {
+    PB0, PA7, PA6 , PA5 , PA4 , PA3 , PA2 , PA1 , PA0 
+};
+
+// Note. These defines are not really used by generic boards. They are for  Maple Serial USB
+#define USB_DP PA12
+#define USB_DM PA11
+
+// NOte. These definitions are not really used for generic boards, they only relate to boards modified to behave like Maple boards
+extern const uint8 boardUsedPins[BOARD_NR_USED_PINS] __FLASH__ = {
+     USB_DP, USB_DM
+};
+
+
+/* 
+ * Roger Clark
+ * 
+ * 2015/05/28
+ *
+ * Moved definitions for Hardware Serial devices from HardwareSerial.cpp so that each board can define which Arduino "Serial" instance
+ * Maps to which hardware serial port on the microprocessor
+ */
+						
+DEFINE_HWSERIAL(Serial1, 1);
+DEFINE_HWSERIAL(Serial2, 2);
+DEFINE_HWSERIAL(Serial3, 3);
diff --git a/STM32F1/variants/generic_gd32f103c2/board/board.h b/STM32F1/variants/generic_gd32f103c2/board/board.h
new file mode 100644
index 0000000..e9451d6
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f103c2/board/board.h
@@ -0,0 +1,90 @@
+/******************************************************************************
+ * The MIT License
+ *
+ * Copyright (c) 2011 LeafLabs, LLC.
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation
+ * files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy,
+ * modify, merge, publish, distribute, sublicense, and/or sell copies
+ * of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *****************************************************************************/
+
+/**
+ * @file   wirish/boards/maple_mini/include/board/board.h
+ * @author Marti Bolivar <mbolivar@leaflabs.com>
+ * @brief  Maple Mini board header.
+ *
+ * See wirish/boards/maple/include/board/board.h for more information
+ * on these definitions.
+ */
+
+#ifndef _BOARD_GENERIC_STM32F103C_H_
+#define _BOARD_GENERIC_STM32F103C_H_
+
+#define CYCLES_PER_MICROSECOND	(F_CPU / 1000000U)
+#define SYSTICK_RELOAD_VAL     (F_CPU/1000) - 1 /* takes a cycle to reload */
+
+#define BOARD_NR_USARTS           3
+#define BOARD_USART1_TX_PIN       PA9
+#define BOARD_USART1_RX_PIN       PA10
+#define BOARD_USART2_TX_PIN       PA2
+#define BOARD_USART2_RX_PIN       PA3
+#define BOARD_USART3_TX_PIN       PB10
+#define BOARD_USART3_RX_PIN       PB11
+
+#define BOARD_NR_SPI              2
+#define BOARD_SPI1_NSS_PIN        PA4
+#define BOARD_SPI1_MOSI_PIN       PA7
+#define BOARD_SPI1_MISO_PIN       PA6
+#define BOARD_SPI1_SCK_PIN        PA5
+
+#define BOARD_SPI1_ALT_NSS_PIN    PA15
+#define BOARD_SPI1_ALT_MOSI_PIN   PB5
+#define BOARD_SPI1_ALT_MISO_PIN   PB4
+#define BOARD_SPI1_ALT_SCK_PIN    PB3
+
+#define BOARD_SPI2_NSS_PIN        PB12
+#define BOARD_SPI2_MOSI_PIN       PB15
+#define BOARD_SPI2_MISO_PIN       PB14
+#define BOARD_SPI2_SCK_PIN        PB13
+
+#define BOARD_NR_GPIO_PINS        35
+#define BOARD_NR_PWM_PINS         12
+#define BOARD_NR_ADC_PINS          9
+#define BOARD_NR_USED_PINS         4
+
+
+#define BOARD_JTMS_SWDIO_PIN      22
+#define BOARD_JTCK_SWCLK_PIN      21
+#define BOARD_JTDI_PIN            20
+#define BOARD_JTDO_PIN            19
+#define BOARD_NJTRST_PIN          18
+
+#define BOARD_USB_DISC_DEV        NULL
+#define BOARD_USB_DISC_BIT        NULL
+
+#define LED_BUILTIN PC13
+
+// Note this needs to match with the PIN_MAP array in board.cpp
+enum {
+    PA0, PA1, PA2, PA3, PA4, PA5, PA6, PA7, PA8, PA9, PA10, PA11, PA12, PA13,PA14,PA15,
+	PB0, PB1, PB2, PB3, PB4, PB5, PB6, PB7, PB8, PB9, PB10, PB11, PB12, PB13,PB14,PB15,
+	PC13, PC14,PC15
+};
+
+#endif
diff --git a/STM32F1/variants/generic_gd32f103c2/ld/bootloader_20.ld b/STM32F1/variants/generic_gd32f103c2/ld/bootloader_20.ld
new file mode 100644
index 0000000..052915c
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f103c2/ld/bootloader_20.ld
@@ -0,0 +1,30 @@
+/*
+ * libmaple linker script for "Flash" builds.
+ *
+ * A Flash build puts .text (and .rodata) in Flash, and
+ * .data/.bss/heap (of course) in SRAM, but offsets the sections by
+ * enough space to store the Maple bootloader, which lives in low
+ * Flash and uses low memory.
+ */
+
+/*
+ * This pulls in the appropriate MEMORY declaration from the right
+ * subdirectory of stm32/mem/ (the environment must call ld with the
+ * right include directory flags to make this happen). Boards can also
+ * use this file to use any of libmaple's memory-related hooks (like
+ * where the heap should live).
+ */
+MEMORY
+{
+  ram (rwx) : ORIGIN = 0x20000000, LENGTH = 48K
+  rom (rx)  : ORIGIN = 0x08002000, LENGTH = 248K
+}
+
+/* Provide memory region aliases for common.inc */
+REGION_ALIAS("REGION_TEXT", rom);
+REGION_ALIAS("REGION_DATA", ram);
+REGION_ALIAS("REGION_BSS", ram);
+REGION_ALIAS("REGION_RODATA", rom);
+
+/* Let common.inc handle the real work. */
+INCLUDE common.inc
diff --git a/STM32F1/variants/generic_gd32f103c2/ld/bootloader_20_c6.ld b/STM32F1/variants/generic_gd32f103c2/ld/bootloader_20_c6.ld
new file mode 100755
index 0000000..499efcc
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f103c2/ld/bootloader_20_c6.ld
@@ -0,0 +1,30 @@
+/*
+ * libmaple linker script for "Flash" builds.
+ *
+ * A Flash build puts .text (and .rodata) in Flash, and
+ * .data/.bss/heap (of course) in SRAM, but offsets the sections by
+ * enough space to store the Maple bootloader, which lives in low
+ * Flash and uses low memory.
+ */
+
+/*
+ * This pulls in the appropriate MEMORY declaration from the right
+ * subdirectory of stm32/mem/ (the environment must call ld with the
+ * right include directory flags to make this happen). Boards can also
+ * use this file to use any of libmaple's memory-related hooks (like
+ * where the heap should live).
+ */
+MEMORY
+{
+  ram (rwx) : ORIGIN = 0x20000000, LENGTH = 10K
+  rom (rx)  : ORIGIN = 0x08002000, LENGTH = 24K
+}
+
+/* Provide memory region aliases for common.inc */
+REGION_ALIAS("REGION_TEXT", rom);
+REGION_ALIAS("REGION_DATA", ram);
+REGION_ALIAS("REGION_BSS", ram);
+REGION_ALIAS("REGION_RODATA", rom);
+
+/* Let common.inc handle the real work. */
+INCLUDE common.inc
diff --git a/STM32F1/variants/generic_gd32f103c2/ld/common.inc b/STM32F1/variants/generic_gd32f103c2/ld/common.inc
new file mode 100644
index 0000000..0c2b6a4
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f103c2/ld/common.inc
@@ -0,0 +1,220 @@
+/*
+ * Linker script for libmaple.
+ *
+ * Original author "lanchon" from ST forums, with modifications by LeafLabs.
+ */
+
+OUTPUT_FORMAT ("elf32-littlearm", "elf32-bigarm", "elf32-littlearm")
+
+/*
+ * Configure other libraries we want in the link.
+ *
+ * libgcc, libc, and libm are common across supported toolchains.
+ * However, some toolchains require additional archives which aren't
+ * present everywhere (e.g. ARM's gcc-arm-embedded releases).
+ *
+ * To hack around this, we let the build system specify additional
+ * archives by putting the right extra_libs.inc (in a directory under
+ * toolchains/) in our search path.
+ */
+GROUP(libgcc.a libc.a libm.a)
+INCLUDE extra_libs.inc
+
+/*
+ * These force the linker to search for vector table symbols.
+ *
+ * These symbols vary by STM32 family (and also within families).
+ * It's up to the build system to configure the link's search path
+ * properly for the target MCU.
+ */
+INCLUDE vector_symbols.inc
+
+/* STM32 vector table. */
+EXTERN(__stm32_vector_table)
+
+/* C runtime initialization function. */
+EXTERN(start_c)
+
+/* main entry point */
+EXTERN(main)
+
+/* Initial stack pointer value. */
+EXTERN(__msp_init)
+PROVIDE(__msp_init = ORIGIN(ram) + LENGTH(ram));
+
+/* Reset vector and chip reset entry point */
+EXTERN(__start__)
+ENTRY(__start__)
+PROVIDE(__exc_reset = __start__);
+
+/* Heap boundaries, for libmaple */
+EXTERN(_lm_heap_start);
+EXTERN(_lm_heap_end);
+
+SECTIONS
+{
+    .text :
+      {
+        __text_start__ = .;
+        /*
+         * STM32 vector table.  Leave this here.  Yes, really.
+         */
+        *(.stm32.interrupt_vector)
+
+        /*
+         * Program code and vague linking
+         */
+        *(.text .text.* .gnu.linkonce.t.*)
+        *(.plt)
+        *(.gnu.warning)
+        *(.glue_7t) *(.glue_7) *(.vfp11_veneer)
+
+        *(.ARM.extab* .gnu.linkonce.armextab.*)
+        *(.gcc_except_table)
+        *(.eh_frame_hdr)
+        *(.eh_frame)
+
+        . = ALIGN(4);
+        KEEP(*(.init))
+
+        . = ALIGN(4);
+        __preinit_array_start = .;
+        KEEP (*(.preinit_array))
+        __preinit_array_end = .;
+
+        . = ALIGN(4);
+        __init_array_start = .;
+        KEEP (*(SORT(.init_array.*)))
+        KEEP (*(.init_array))
+        __init_array_end = .;
+
+        . = ALIGN(0x4);
+        KEEP (*crtbegin.o(.ctors))
+        KEEP (*(EXCLUDE_FILE (*crtend.o) .ctors))
+        KEEP (*(SORT(.ctors.*)))
+        KEEP (*crtend.o(.ctors))
+
+        . = ALIGN(4);
+        KEEP(*(.fini))
+
+        . = ALIGN(4);
+        __fini_array_start = .;
+        KEEP (*(.fini_array))
+        KEEP (*(SORT(.fini_array.*)))
+        __fini_array_end = .;
+
+        KEEP (*crtbegin.o(.dtors))
+        KEEP (*(EXCLUDE_FILE (*crtend.o) .dtors))
+        KEEP (*(SORT(.dtors.*)))
+        KEEP (*crtend.o(.dtors))
+      } > REGION_TEXT
+
+    /*
+     * End of text
+     */
+    .text.align :
+      {
+        . = ALIGN(8);
+        __text_end__ = .;
+      } > REGION_TEXT
+
+    /*
+     * .ARM.exidx exception unwinding; mandated by ARM's C++ ABI
+     */
+    __exidx_start = .;
+    .ARM.exidx :
+      {
+        *(.ARM.exidx* .gnu.linkonce.armexidx.*)
+      } > REGION_RODATA
+    __exidx_end = .;
+
+    /*
+     * .data
+     */
+    .data :
+      {
+        __data_start__ = .;
+      	LONG(0)
+        . = ALIGN(8);
+
+        *(.got.plt) *(.got)
+        *(.data .data.* .gnu.linkonce.d.*)
+
+        . = ALIGN(8);
+        __data_end__ = .;
+      } > REGION_DATA AT> REGION_RODATA
+
+    /*
+     * Read-only data
+     */
+    .rodata :
+      {
+        *(.rodata .rodata.* .gnu.linkonce.r.*)
+        /* .USER_FLASH: We allow users to allocate into Flash here */
+        *(.USER_FLASH)
+        /* ROM image configuration; for C startup */
+        . = ALIGN(4);
+        _lm_rom_img_cfgp = .;
+        LONG(LOADADDR(.data));
+        /*
+         * Heap: Linker scripts may choose a custom heap by overriding
+         * _lm_heap_start and _lm_heap_end. Otherwise, the heap is in
+         * internal SRAM, beginning after .bss, and growing towards
+         * the stack.
+         *
+         * I'm shoving these here naively; there's probably a cleaner way
+         * to go about this. [mbolivar]
+         */
+        _lm_heap_start = DEFINED(_lm_heap_start) ? _lm_heap_start : _end;
+        _lm_heap_end   = DEFINED(_lm_heap_end) ? _lm_heap_end : __msp_init;
+      } > REGION_RODATA
+
+    /*
+     * .bss
+     */
+    .bss :
+      {
+        . = ALIGN(8);
+        __bss_start__ = .;
+        *(.bss .bss.* .gnu.linkonce.b.*)
+        *(COMMON)
+        . = ALIGN (8);
+        __bss_end__ = .;
+        _end = __bss_end__;
+      } > REGION_BSS
+
+    /*
+     * Debugging sections
+     */
+    .stab 0 (NOLOAD) : { *(.stab) }
+    .stabstr 0 (NOLOAD) : { *(.stabstr) }
+    /* DWARF debug sections.
+     * Symbols in the DWARF debugging sections are relative to the beginning
+     * of the section so we begin them at 0.  */
+    /* DWARF 1 */
+    .debug          0 : { *(.debug) }
+    .line           0 : { *(.line) }
+    /* GNU DWARF 1 extensions */
+    .debug_srcinfo  0 : { *(.debug_srcinfo) }
+    .debug_sfnames  0 : { *(.debug_sfnames) }
+    /* DWARF 1.1 and DWARF 2 */
+    .debug_aranges  0 : { *(.debug_aranges) }
+    .debug_pubnames 0 : { *(.debug_pubnames) }
+    /* DWARF 2 */
+    .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }
+    .debug_abbrev   0 : { *(.debug_abbrev) }
+    .debug_line     0 : { *(.debug_line) }
+    .debug_frame    0 : { *(.debug_frame) }
+    .debug_str      0 : { *(.debug_str) }
+    .debug_loc      0 : { *(.debug_loc) }
+    .debug_macinfo  0 : { *(.debug_macinfo) }
+    /* SGI/MIPS DWARF 2 extensions */
+    .debug_weaknames 0 : { *(.debug_weaknames) }
+    .debug_funcnames 0 : { *(.debug_funcnames) }
+    .debug_typenames 0 : { *(.debug_typenames) }
+    .debug_varnames  0 : { *(.debug_varnames) }
+
+    .note.gnu.arm.ident 0 : { KEEP (*(.note.gnu.arm.ident)) }
+    .ARM.attributes 0 : { KEEP (*(.ARM.attributes)) }
+    /DISCARD/ : { *(.note.GNU-stack) }
+}
diff --git a/STM32F1/variants/generic_gd32f103c2/ld/extra_libs.inc b/STM32F1/variants/generic_gd32f103c2/ld/extra_libs.inc
new file mode 100644
index 0000000..4413a53
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f103c2/ld/extra_libs.inc
@@ -0,0 +1,7 @@
+/*
+ * Extra archives needed by ARM's GCC ARM Embedded arm-none-eabi-
+ * releases (https://launchpad.net/gcc-arm-embedded/).
+ */
+
+/* This is for the provided newlib. */
+GROUP(libnosys.a)
diff --git a/STM32F1/variants/generic_gd32f103c2/ld/flash.ld b/STM32F1/variants/generic_gd32f103c2/ld/flash.ld
new file mode 100644
index 0000000..38a3023
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f103c2/ld/flash.ld
@@ -0,0 +1,26 @@
+/*
+ * libmaple linker script for "Flash" builds.
+ *
+ * A Flash build puts .text (and .rodata) in Flash, and
+ * .data/.bss/heap (of course) in SRAM, but offsets the sections by
+ * enough space to store the Maple bootloader, which lives in low
+ * Flash and uses low memory.
+ */
+
+/*
+ * This pulls in the appropriate MEMORY declaration from the right
+ * subdirectory of stm32/mem/ (the environment must call ld with the
+ * right include directory flags to make this happen). Boards can also
+ * use this file to use any of libmaple's memory-related hooks (like
+ * where the heap should live).
+ */
+INCLUDE mem-flash.inc
+
+/* Provide memory region aliases for common.inc */
+REGION_ALIAS("REGION_TEXT", rom);
+REGION_ALIAS("REGION_DATA", ram);
+REGION_ALIAS("REGION_BSS", ram);
+REGION_ALIAS("REGION_RODATA", rom);
+
+/* Let common.inc handle the real work. */
+INCLUDE common.inc
diff --git a/STM32F1/variants/generic_gd32f103c2/ld/flash_c8.ld b/STM32F1/variants/generic_gd32f103c2/ld/flash_c8.ld
new file mode 100644
index 0000000..2a35550
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f103c2/ld/flash_c8.ld
@@ -0,0 +1,33 @@
+/*
+ * libmaple linker script for "Flash" builds.
+ *
+ * A Flash build puts .text (and .rodata) in Flash, and
+ * .data/.bss/heap (of course) in SRAM, but offsets the sections by
+ * enough space to store the Maple bootloader, which lives in low
+ * Flash and uses low memory.
+ */
+
+/*
+ * This pulls in the appropriate MEMORY declaration from the right
+ * subdirectory of stm32/mem/ (the environment must call ld with the
+ * right include directory flags to make this happen). Boards can also
+ * use this file to use any of libmaple's memory-related hooks (like
+ * where the heap should live).
+ */
+/*INCLUDE mem-flash.inc*/
+
+MEMORY
+{
+  ram (rwx) : ORIGIN = 0x20000C00, LENGTH = 17K
+  rom (rx)  : ORIGIN = 0x08000000, LENGTH = 44K
+}
+
+
+/* Provide memory region aliases for common.inc */
+REGION_ALIAS("REGION_TEXT", rom);
+REGION_ALIAS("REGION_DATA", ram);
+REGION_ALIAS("REGION_BSS", ram);
+REGION_ALIAS("REGION_RODATA", rom);
+
+/* Let common.inc handle the real work. */
+INCLUDE common.inc
diff --git a/STM32F1/variants/generic_gd32f103c2/ld/hid_bootloader.ld b/STM32F1/variants/generic_gd32f103c2/ld/hid_bootloader.ld
new file mode 100644
index 0000000..d5b1f06
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f103c2/ld/hid_bootloader.ld
@@ -0,0 +1,30 @@
+/*
+ * libmaple linker script for "Flash" builds.
+ *
+ * A Flash build puts .text (and .rodata) in Flash, and
+ * .data/.bss/heap (of course) in SRAM, but offsets the sections by
+ * enough space to store the Maple bootloader, which lives in low
+ * Flash and uses low memory.
+ */
+
+/*
+ * This pulls in the appropriate MEMORY declaration from the right
+ * subdirectory of stm32/mem/ (the environment must call ld with the
+ * right include directory flags to make this happen). Boards can also
+ * use this file to use any of libmaple's memory-related hooks (like
+ * where the heap should live).
+ */
+MEMORY
+{
+  ram (rwx) : ORIGIN = 0x20000000, LENGTH = 20K
+  rom (rx)  : ORIGIN = 0x08001000, LENGTH = 124K
+}
+
+/* Provide memory region aliases for common.inc */
+REGION_ALIAS("REGION_TEXT", rom);
+REGION_ALIAS("REGION_DATA", ram);
+REGION_ALIAS("REGION_BSS", ram);
+REGION_ALIAS("REGION_RODATA", rom);
+
+/* Let common.inc handle the real work. */
+INCLUDE common.inc
diff --git a/STM32F1/variants/generic_gd32f103c2/ld/hid_bootloader_c6.ld b/STM32F1/variants/generic_gd32f103c2/ld/hid_bootloader_c6.ld
new file mode 100644
index 0000000..e758192
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f103c2/ld/hid_bootloader_c6.ld
@@ -0,0 +1,30 @@
+/*
+ * libmaple linker script for "Flash" builds.
+ *
+ * A Flash build puts .text (and .rodata) in Flash, and
+ * .data/.bss/heap (of course) in SRAM, but offsets the sections by
+ * enough space to store the Maple bootloader, which lives in low
+ * Flash and uses low memory.
+ */
+
+/*
+ * This pulls in the appropriate MEMORY declaration from the right
+ * subdirectory of stm32/mem/ (the environment must call ld with the
+ * right include directory flags to make this happen). Boards can also
+ * use this file to use any of libmaple's memory-related hooks (like
+ * where the heap should live).
+ */
+MEMORY
+{
+  ram (rwx) : ORIGIN = 0x20000000, LENGTH = 10K
+  rom (rx)  : ORIGIN = 0x08001000, LENGTH = 24K
+}
+
+/* Provide memory region aliases for common.inc */
+REGION_ALIAS("REGION_TEXT", rom);
+REGION_ALIAS("REGION_DATA", ram);
+REGION_ALIAS("REGION_BSS", ram);
+REGION_ALIAS("REGION_RODATA", rom);
+
+/* Let common.inc handle the real work. */
+INCLUDE common.inc
diff --git a/STM32F1/variants/generic_gd32f103c2/ld/jtag.ld b/STM32F1/variants/generic_gd32f103c2/ld/jtag.ld
new file mode 100644
index 0000000..62ae052
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f103c2/ld/jtag.ld
@@ -0,0 +1,31 @@
+/*
+ * libmaple linker script for "JTAG" builds.
+ *
+ * A "JTAG" build puts .text (and .rodata) in Flash, and
+ * .data/.bss/heap (of course) in SRAM, but links starting at the
+ * Flash and SRAM starting addresses (0x08000000 and 0x20000000
+ * respectively). This will wipe out a Maple bootloader if there's one
+ * on the board, so only use this if you know what you're doing.
+ *
+ * Of course, a "JTAG" build is perfectly usable for upload over SWD,
+ * the system memory bootloader, etc. The name is just a historical
+ * artifact.
+ */
+
+/*
+ * This pulls in the appropriate MEMORY declaration from the right
+ * subdirectory of stm32/mem/ (the environment must call ld with the
+ * right include directory flags to make this happen). Boards can also
+ * use this file to use any of libmaple's memory-related hooks (like
+ * where the heap should live).
+ */
+INCLUDE mem-jtag.inc
+
+/* Provide memory region aliases for common.inc */
+REGION_ALIAS("REGION_TEXT", rom);
+REGION_ALIAS("REGION_DATA", ram);
+REGION_ALIAS("REGION_BSS", ram);
+REGION_ALIAS("REGION_RODATA", rom);
+
+/* Let common.inc handle the real work. */
+INCLUDE common.inc
diff --git a/STM32F1/variants/generic_gd32f103c2/ld/jtag_c6.ld b/STM32F1/variants/generic_gd32f103c2/ld/jtag_c6.ld
new file mode 100644
index 0000000..1684795
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f103c2/ld/jtag_c6.ld
@@ -0,0 +1,36 @@
+/*
+ * libmaple linker script for "JTAG" builds.
+ *
+ * A "JTAG" build puts .text (and .rodata) in Flash, and
+ * .data/.bss/heap (of course) in SRAM, but links starting at the
+ * Flash and SRAM starting addresses (0x08000000 and 0x20000000
+ * respectively). This will wipe out a Maple bootloader if there's one
+ * on the board, so only use this if you know what you're doing.
+ *
+ * Of course, a "JTAG" build is perfectly usable for upload over SWD,
+ * the system memory bootloader, etc. The name is just a historical
+ * artifact.
+ */
+
+/*
+ * This pulls in the appropriate MEMORY declaration from the right
+ * subdirectory of stm32/mem/ (the environment must call ld with the
+ * right include directory flags to make this happen). Boards can also
+ * use this file to use any of libmaple's memory-related hooks (like
+ * where the heap should live).
+ */
+
+MEMORY
+{
+  ram (rwx) : ORIGIN = 0x20000000, LENGTH = 10K
+  rom (rx)  : ORIGIN = 0x08000000, LENGTH = 32K
+}
+
+/* Provide memory region aliases for common.inc */
+REGION_ALIAS("REGION_TEXT", rom);
+REGION_ALIAS("REGION_DATA", ram);
+REGION_ALIAS("REGION_BSS", ram);
+REGION_ALIAS("REGION_RODATA", rom);
+
+/* Let common.inc handle the real work. */
+INCLUDE common.inc
diff --git a/STM32F1/variants/generic_gd32f103c2/ld/jtag_c8.ld b/STM32F1/variants/generic_gd32f103c2/ld/jtag_c8.ld
new file mode 100644
index 0000000..2e01979
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f103c2/ld/jtag_c8.ld
@@ -0,0 +1,36 @@
+/*
+ * libmaple linker script for "JTAG" builds.
+ *
+ * A "JTAG" build puts .text (and .rodata) in Flash, and
+ * .data/.bss/heap (of course) in SRAM, but links starting at the
+ * Flash and SRAM starting addresses (0x08000000 and 0x20000000
+ * respectively). This will wipe out a Maple bootloader if there's one
+ * on the board, so only use this if you know what you're doing.
+ *
+ * Of course, a "JTAG" build is perfectly usable for upload over SWD,
+ * the system memory bootloader, etc. The name is just a historical
+ * artifact.
+ */
+
+/*
+ * This pulls in the appropriate MEMORY declaration from the right
+ * subdirectory of stm32/mem/ (the environment must call ld with the
+ * right include directory flags to make this happen). Boards can also
+ * use this file to use any of libmaple's memory-related hooks (like
+ * where the heap should live).
+ */
+
+MEMORY
+{
+  ram (rwx) : ORIGIN = 0x20000000, LENGTH = 20K
+  rom (rx)  : ORIGIN = 0x08000000, LENGTH = 64K
+}
+
+/* Provide memory region aliases for common.inc */
+REGION_ALIAS("REGION_TEXT", rom);
+REGION_ALIAS("REGION_DATA", ram);
+REGION_ALIAS("REGION_BSS", ram);
+REGION_ALIAS("REGION_RODATA", rom);
+
+/* Let common.inc handle the real work. */
+INCLUDE common.inc
diff --git a/STM32F1/variants/generic_gd32f103c2/ld/mem-flash.inc b/STM32F1/variants/generic_gd32f103c2/ld/mem-flash.inc
new file mode 100644
index 0000000..1a9c32e
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f103c2/ld/mem-flash.inc
@@ -0,0 +1,5 @@
+MEMORY
+{
+  ram (rwx) : ORIGIN = 0x20000C00, LENGTH = 45K
+  rom (rx)  : ORIGIN = 0x08005000, LENGTH = 236K
+}
diff --git a/STM32F1/variants/generic_gd32f103c2/ld/mem-jtag.inc b/STM32F1/variants/generic_gd32f103c2/ld/mem-jtag.inc
new file mode 100644
index 0000000..bd6f796
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f103c2/ld/mem-jtag.inc
@@ -0,0 +1,5 @@
+MEMORY
+{
+  ram (rwx) : ORIGIN = 0x20000000, LENGTH = 20K
+  rom (rx)  : ORIGIN = 0x08000000, LENGTH = 64K
+}
diff --git a/STM32F1/variants/generic_gd32f103c2/ld/mem-ram.inc b/STM32F1/variants/generic_gd32f103c2/ld/mem-ram.inc
new file mode 100644
index 0000000..dc6d329
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f103c2/ld/mem-ram.inc
@@ -0,0 +1,5 @@
+MEMORY
+{
+  ram (rwx) : ORIGIN = 0x20000C00, LENGTH = 17K
+  rom (rx)  : ORIGIN = 0x08005000, LENGTH = 0K
+}
diff --git a/STM32F1/variants/generic_gd32f103c2/ld/ram.ld b/STM32F1/variants/generic_gd32f103c2/ld/ram.ld
new file mode 100644
index 0000000..1ea7598
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f103c2/ld/ram.ld
@@ -0,0 +1,25 @@
+/*
+ * libmaple linker script for RAM builds.
+ *
+ * A Flash build puts .text, .rodata, and .data/.bss/heap (of course)
+ * in SRAM, but offsets the sections by enough space to store the
+ * Maple bootloader, which uses low memory.
+ */
+
+/*
+ * This pulls in the appropriate MEMORY declaration from the right
+ * subdirectory of stm32/mem/ (the environment must call ld with the
+ * right include directory flags to make this happen). Boards can also
+ * use this file to use any of libmaple's memory-related hooks (like
+ * where the heap should live).
+ */
+INCLUDE mem-ram.inc
+
+/* Provide memory region aliases for common.inc */
+REGION_ALIAS("REGION_TEXT", ram);
+REGION_ALIAS("REGION_DATA", ram);
+REGION_ALIAS("REGION_BSS", ram);
+REGION_ALIAS("REGION_RODATA", ram);
+
+/* Let common.inc handle the real work. */
+INCLUDE common.inc
diff --git a/STM32F1/variants/generic_gd32f103c2/ld/ram_c8.ld b/STM32F1/variants/generic_gd32f103c2/ld/ram_c8.ld
new file mode 100644
index 0000000..9f9f6bb
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f103c2/ld/ram_c8.ld
@@ -0,0 +1,31 @@
+/*
+ * libmaple linker script for RAM builds.
+ *
+ * A Flash build puts .text, .rodata, and .data/.bss/heap (of course)
+ * in SRAM, but offsets the sections by enough space to store the
+ * Maple bootloader, which uses low memory.
+ */
+
+/*
+ * This pulls in the appropriate MEMORY declaration from the right
+ * subdirectory of stm32/mem/ (the environment must call ld with the
+ * right include directory flags to make this happen). Boards can also
+ * use this file to use any of libmaple's memory-related hooks (like
+ * where the heap should live).
+ */
+/*INCLUDE mem-ram.inc*/
+MEMORY
+{
+  ram (rwx) : ORIGIN = 0x20000C00, LENGTH = 17K
+  rom (rx)  : ORIGIN = 0x08005000, LENGTH = 0
+}
+
+
+/* Provide memory region aliases for common.inc */
+REGION_ALIAS("REGION_TEXT", ram);
+REGION_ALIAS("REGION_DATA", ram);
+REGION_ALIAS("REGION_BSS", ram);
+REGION_ALIAS("REGION_RODATA", ram);
+
+/* Let common.inc handle the real work. */
+INCLUDE common.inc
diff --git a/STM32F1/variants/generic_gd32f103c2/ld/vector_symbols.inc b/STM32F1/variants/generic_gd32f103c2/ld/vector_symbols.inc
new file mode 100644
index 0000000..a40012a
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f103c2/ld/vector_symbols.inc
@@ -0,0 +1,78 @@
+EXTERN(__msp_init)
+EXTERN(__exc_reset)
+EXTERN(__exc_nmi)
+EXTERN(__exc_hardfault)
+EXTERN(__exc_memmanage)
+EXTERN(__exc_busfault)
+EXTERN(__exc_usagefault)
+EXTERN(__stm32reservedexception7)
+EXTERN(__stm32reservedexception8)
+EXTERN(__stm32reservedexception9)
+EXTERN(__stm32reservedexception10)
+EXTERN(__exc_svc)
+EXTERN(__exc_debug_monitor)
+EXTERN(__stm32reservedexception13)
+EXTERN(__exc_pendsv)
+EXTERN(__exc_systick)
+
+EXTERN(__irq_wwdg)
+EXTERN(__irq_pvd)
+EXTERN(__irq_tamper)
+EXTERN(__irq_rtc)
+EXTERN(__irq_flash)
+EXTERN(__irq_rcc)
+EXTERN(__irq_exti0)
+EXTERN(__irq_exti1)
+EXTERN(__irq_exti2)
+EXTERN(__irq_exti3)
+EXTERN(__irq_exti4)
+EXTERN(__irq_dma1_channel1)
+EXTERN(__irq_dma1_channel2)
+EXTERN(__irq_dma1_channel3)
+EXTERN(__irq_dma1_channel4)
+EXTERN(__irq_dma1_channel5)
+EXTERN(__irq_dma1_channel6)
+EXTERN(__irq_dma1_channel7)
+EXTERN(__irq_adc)
+EXTERN(__irq_usb_hp_can_tx)
+EXTERN(__irq_usb_lp_can_rx0)
+EXTERN(__irq_can_rx1)
+EXTERN(__irq_can_sce)
+EXTERN(__irq_exti9_5)
+EXTERN(__irq_tim1_brk)
+EXTERN(__irq_tim1_up)
+EXTERN(__irq_tim1_trg_com)
+EXTERN(__irq_tim1_cc)
+EXTERN(__irq_tim2)
+EXTERN(__irq_tim3)
+EXTERN(__irq_tim4)
+EXTERN(__irq_i2c1_ev)
+EXTERN(__irq_i2c1_er)
+EXTERN(__irq_i2c2_ev)
+EXTERN(__irq_i2c2_er)
+EXTERN(__irq_spi1)
+EXTERN(__irq_spi2)
+EXTERN(__irq_usart1)
+EXTERN(__irq_usart2)
+EXTERN(__irq_usart3)
+EXTERN(__irq_exti15_10)
+EXTERN(__irq_rtcalarm)
+EXTERN(__irq_usbwakeup)
+
+EXTERN(__irq_tim8_brk)
+EXTERN(__irq_tim8_up)
+EXTERN(__irq_tim8_trg_com)
+EXTERN(__irq_tim8_cc)
+EXTERN(__irq_adc3)
+EXTERN(__irq_fsmc)
+EXTERN(__irq_sdio)
+EXTERN(__irq_tim5)
+EXTERN(__irq_spi3)
+EXTERN(__irq_uart4)
+EXTERN(__irq_uart5)
+EXTERN(__irq_tim6)
+EXTERN(__irq_tim7)
+EXTERN(__irq_dma2_channel1)
+EXTERN(__irq_dma2_channel2)
+EXTERN(__irq_dma2_channel3)
+EXTERN(__irq_dma2_channel4_5)
diff --git a/STM32F1/variants/generic_gd32f103c2/pins_arduino.h b/STM32F1/variants/generic_gd32f103c2/pins_arduino.h
new file mode 100644
index 0000000..d7518e6
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f103c2/pins_arduino.h
@@ -0,0 +1,6 @@
+
+
+
+
+// API compatibility
+#include "variant.h"
\ No newline at end of file
diff --git a/STM32F1/variants/generic_gd32f103c2/variant.h b/STM32F1/variants/generic_gd32f103c2/variant.h
new file mode 100644
index 0000000..dc4b894
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f103c2/variant.h
@@ -0,0 +1,22 @@
+#ifndef _VARIANT_ARDUINO_STM32_
+#define _VARIANT_ARDUINO_STM32_
+
+#define digitalPinToPort(P)        ( PIN_MAP[P].gpio_device )
+#define digitalPinToBitMask(P)     ( BIT(PIN_MAP[P].gpio_bit) )
+#define portOutputRegister(port)   ( &(port->regs->ODR) )
+#define portInputRegister(port)    ( &(port->regs->IDR) )
+
+#define portSetRegister(pin)		( &(PIN_MAP[pin].gpio_device->regs->BSRR) )
+#define portClearRegister(pin)		( &(PIN_MAP[pin].gpio_device->regs->BRR) )
+
+#define portConfigRegister(pin)		( &(PIN_MAP[pin].gpio_device->regs->CRL) )
+
+static const uint8_t SS   = BOARD_SPI1_NSS_PIN;
+static const uint8_t SS1  = BOARD_SPI2_NSS_PIN;
+static const uint8_t MOSI = BOARD_SPI1_MOSI_PIN;
+static const uint8_t MISO = BOARD_SPI1_MISO_PIN;
+static const uint8_t SCK  = BOARD_SPI1_SCK_PIN;
+
+#define LED_BUILTIN PC13
+
+#endif /* _VARIANT_ARDUINO_STM32_ */
diff --git a/STM32F1/variants/generic_gd32f103c2/wirish/boards.cpp b/STM32F1/variants/generic_gd32f103c2/wirish/boards.cpp
new file mode 100644
index 0000000..53f3469
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f103c2/wirish/boards.cpp
@@ -0,0 +1,225 @@
+/******************************************************************************
+ * The MIT License
+ *
+ * Copyright (c) 2010 Perry Hung.
+ * Copyright (c) 2011, 2012 LeafLabs, LLC.
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation
+ * files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy,
+ * modify, merge, publish, distribute, sublicense, and/or sell copies
+ * of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *****************************************************************************/
+
+/**
+ * @file wirish/boards.cpp
+ * @brief init() and board routines.
+ *
+ * This file is mostly interesting for the init() function, which
+ * configures Flash, the core clocks, and a variety of other available
+ * peripherals on the board so the rest of Wirish doesn't have to turn
+ * things on before using them.
+ *
+ * Prior to returning, init() calls boardInit(), which allows boards
+ * to perform any initialization they need to. This file includes a
+ * weak no-op definition of boardInit(), so boards that don't need any
+ * special initialization don't have to define their own.
+ *
+ * How init() works is chip-specific. See the boards_setup.cpp files
+ * under e.g. wirish/stm32f1/, wirish/stmf32f2 for the details, but be
+ * advised: their contents are unstable, and can/will change without
+ * notice.
+ */
+
+#include <boards.h>
+#include <libmaple/libmaple_types.h>
+#include <libmaple/flash.h>
+#include <libmaple/nvic.h>
+#include <libmaple/systick.h>
+#include "boards_private.h"
+
+static void setup_flash(void);
+static void setup_clocks(void);
+static void setup_nvic(void);
+static void setup_adcs(void);
+static void setup_timers(void);
+
+/*
+ * Exported functions
+ */
+
+void init(void) {
+    setup_flash();
+    setup_clocks();
+    setup_nvic();
+    systick_init(SYSTICK_RELOAD_VAL);
+    wirish::priv::board_setup_gpio();
+    setup_adcs();
+    setup_timers();
+    wirish::priv::board_setup_usb();
+    wirish::priv::series_init();
+    boardInit();
+}
+
+/* Provide a default no-op boardInit(). */
+__weak void boardInit(void) {
+}
+
+/* You could farm this out to the files in boards/ if e.g. it takes
+ * too long to test on boards with lots of pins. */
+bool boardUsesPin(uint8 pin) {
+    for (int i = 0; i < BOARD_NR_USED_PINS; i++) {
+        if (pin == boardUsedPins[i]) {
+            return true;
+        }
+    }
+    return false;
+}
+
+/*
+ * Auxiliary routines
+ */
+
+static void setup_flash(void) {
+    // Turn on as many Flash "go faster" features as
+    // possible. flash_enable_features() just ignores any flags it
+    // can't support.
+    flash_enable_features(FLASH_PREFETCH | FLASH_ICACHE | FLASH_DCACHE);
+    // Configure the wait states, assuming we're operating at "close
+    // enough" to 3.3V.
+    flash_set_latency(FLASH_SAFE_WAIT_STATES);
+}
+
+static void setup_clocks(void) {
+    // Turn on HSI. We'll switch to and run off of this while we're
+    // setting up the main PLL.
+    rcc_turn_on_clk(RCC_CLK_HSI);
+
+    // Turn off and reset the clock subsystems we'll be using, as well
+    // as the clock security subsystem (CSS). Note that resetting CFGR
+    // to its default value of 0 implies a switch to HSI for SYSCLK.
+    RCC_BASE->CFGR = 0x00000000;
+    rcc_disable_css();
+    rcc_turn_off_clk(RCC_CLK_PLL);
+    rcc_turn_off_clk(RCC_CLK_HSE);
+    wirish::priv::board_reset_pll();
+    // Clear clock readiness interrupt flags and turn off clock
+    // readiness interrupts.
+    RCC_BASE->CIR = 0x00000000;
+#if !USE_HSI_CLOCK
+    // Enable HSE, and wait until it's ready.
+    rcc_turn_on_clk(RCC_CLK_HSE);
+    while (!rcc_is_clk_ready(RCC_CLK_HSE))
+        ;
+#endif
+    // Configure AHBx, APBx, etc. prescalers and the main PLL.
+    wirish::priv::board_setup_clock_prescalers();
+    rcc_configure_pll(&wirish::priv::w_board_pll_cfg);
+
+    // Enable the PLL, and wait until it's ready.
+    rcc_turn_on_clk(RCC_CLK_PLL);
+    while(!rcc_is_clk_ready(RCC_CLK_PLL))
+        ;
+
+    // Finally, switch to the now-ready PLL as the main clock source.
+    rcc_switch_sysclk(RCC_CLKSRC_PLL);
+}
+
+/*
+ * These addresses are where usercode starts when a bootloader is
+ * present. If no bootloader is present, the user NVIC usually starts
+ * at the Flash base address, 0x08000000.
+ */
+#if defined(BOOTLOADER_maple)
+	#define USER_ADDR_ROM 0x08005000
+#else
+	#define USER_ADDR_ROM 0x08000000
+#endif
+#define USER_ADDR_RAM 0x20000C00
+extern char __text_start__;
+
+static void setup_nvic(void) {
+
+nvic_init((uint32)VECT_TAB_ADDR, 0);
+
+/* Roger Clark. We now control nvic vector table in boards.txt using the build.vect paramater
+#ifdef VECT_TAB_FLASH
+    nvic_init(USER_ADDR_ROM, 0);
+#elif defined VECT_TAB_RAM
+    nvic_init(USER_ADDR_RAM, 0);
+#elif defined VECT_TAB_BASE
+    nvic_init((uint32)0x08000000, 0);
+#elif defined VECT_TAB_ADDR
+    // A numerically supplied value
+    nvic_init((uint32)VECT_TAB_ADDR, 0);
+#else
+    // Use the __text_start__ value from the linker script; this
+    // should be the start of the vector table.
+    nvic_init((uint32)&__text_start__, 0);
+#endif
+
+*/
+}
+
+static void adc_default_config( adc_dev *dev) {
+    adc_enable_single_swstart(dev);
+    adc_set_sample_rate(dev, wirish::priv::w_adc_smp);
+}
+
+static void setup_adcs(void) {
+    adc_set_prescaler(wirish::priv::w_adc_pre);
+    adc_foreach(adc_default_config);
+}
+
+static void timer_default_config(timer_dev *dev) {
+    timer_adv_reg_map *regs = (dev->regs).adv;
+    const uint16 full_overflow = 0xFFFF;
+    const uint16 half_duty = 0x8FFF;
+
+    timer_init(dev);
+    timer_pause(dev);
+
+    regs->CR1 = TIMER_CR1_ARPE;
+    regs->PSC = 1;
+    regs->SR = 0;
+    regs->DIER = 0;
+    regs->EGR = TIMER_EGR_UG;
+    switch (dev->type) {
+    case TIMER_ADVANCED:
+        regs->BDTR = TIMER_BDTR_MOE | TIMER_BDTR_LOCK_OFF;
+        // fall-through
+    case TIMER_GENERAL:
+        timer_set_reload(dev, full_overflow);
+        for (uint8 channel = 1; channel <= 4; channel++) {
+            if (timer_has_cc_channel(dev, channel)) {
+                timer_set_compare(dev, channel, half_duty);
+                timer_oc_set_mode(dev, channel, TIMER_OC_MODE_PWM_1,
+                                  TIMER_OC_PE);
+            }
+        }
+        // fall-through
+    case TIMER_BASIC:
+        break;
+    }
+
+    timer_generate_update(dev);
+    timer_resume(dev);
+}
+
+static void setup_timers(void) {
+    timer_foreach(timer_default_config);
+}
diff --git a/STM32F1/variants/generic_gd32f103c2/wirish/boards_setup.cpp b/STM32F1/variants/generic_gd32f103c2/wirish/boards_setup.cpp
new file mode 100644
index 0000000..102099f
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f103c2/wirish/boards_setup.cpp
@@ -0,0 +1,129 @@
+/******************************************************************************
+ * The MIT License
+ *
+ * Copyright (c) 2012 LeafLabs, LLC.
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation
+ * files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy,
+ * modify, merge, publish, distribute, sublicense, and/or sell copies
+ * of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+*****************************************************************************/
+
+/**
+ * @file wirish/stm32f1/boards_setup.cpp
+ * @author Marti Bolivar <mbolivar@leaflabs.com>
+ * @brief STM32F1 chip setup.
+ *
+ * This file controls how init() behaves on the STM32F1. Be very
+ * careful when changing anything here. Many of these values depend
+ * upon each other.
+ */
+
+#include "boards_private.h"
+
+#include <libmaple/gpio.h>
+#include <libmaple/timer.h>
+
+#include <boards.h>
+#include <usb_serial.h>
+
+// Allow boards to provide a PLL multiplier. This is useful for
+// e.g. STM32F100 value line MCUs, which use slower multipliers.
+// (We're leaving the default to RCC_PLLMUL_9 for now, since that
+// works for F103 performance line MCUs, which is all that LeafLabs
+// currently officially supports).
+
+// MEANX : We use a 8 Mhz Xtal !
+
+#ifndef BOARD_RCC_PLLMUL
+  #if !USE_HSI_CLOCK
+	#if F_CPU==120000000
+		#define BOARD_RCC_PLLMUL RCC_PLLMUL_14 // stay below 120 Mhz, 14*8=112
+    #elif F_CPU==96000000
+	    #define BOARD_RCC_PLLMUL RCC_PLLMUL_12 // 12*8=96 Mhz
+	#elif F_CPU==72000000
+		#define BOARD_RCC_PLLMUL RCC_PLLMUL_9
+	#elif F_CPU==48000000
+		#define BOARD_RCC_PLLMUL RCC_PLLMUL_6
+	#elif F_CPU==16000000
+		#define BOARD_RCC_PLLMUL RCC_PLLMUL_2
+	#endif
+  #else
+	#define BOARD_RCC_PLLMUL RCC_PLLMUL_16
+  #endif
+#endif
+
+namespace wirish {
+    namespace priv {
+
+        static stm32f1_rcc_pll_data pll_data = {BOARD_RCC_PLLMUL};
+#if !USE_HSI_CLOCK
+        __weak rcc_pll_cfg w_board_pll_cfg = {RCC_PLLSRC_HSE, &pll_data};
+#else
+        __weak rcc_pll_cfg w_board_pll_cfg = {RCC_PLLSRC_HSI_DIV_2, &pll_data};
+#endif
+        __weak adc_prescaler w_adc_pre = ADC_PRE_PCLK2_DIV_6;
+        __weak adc_smp_rate w_adc_smp = ADC_SMPR_55_5;
+
+        __weak void board_reset_pll(void) {
+            // TODO
+        }
+// 48 Mhz USB Clock
+        __weak void board_setup_clock_prescalers(void) {
+            rcc_set_prescaler(RCC_PRESCALER_AHB, RCC_AHB_SYSCLK_DIV_1);
+            rcc_set_prescaler(RCC_PRESCALER_APB1, RCC_APB1_HCLK_DIV_2);
+            rcc_set_prescaler(RCC_PRESCALER_APB2, RCC_APB2_HCLK_DIV_1);
+			rcc_clk_disable(RCC_USB);
+	        #if F_CPU == 120000000
+			rcc_set_prescaler(RCC_PRESCALER_USB, RCC_USB_SYSCLK_DIV_2_5);
+		#elif F_CPU == 96000000
+			rcc_set_prescaler(RCC_PRESCALER_USB, RCC_USB_SYSCLK_DIV_2);
+                #elif F_CPU == 72000000
+			rcc_set_prescaler(RCC_PRESCALER_USB, RCC_USB_SYSCLK_DIV_1_5);
+                #elif F_CPU == 48000000
+			rcc_set_prescaler(RCC_PRESCALER_USB, RCC_USB_SYSCLK_DIV_1);			
+                #endif	
+        }
+
+        __weak void board_setup_gpio(void) {
+            gpio_init_all();
+        }
+
+        __weak void board_setup_usb(void) {
+#ifdef SERIAL_USB
+			
+#ifdef GENERIC_BOOTLOADER			
+			//Reset the USB interface on generic boards - developed by Victor PV
+			gpio_set_mode(PIN_MAP[PA12].gpio_device, PIN_MAP[PA12].gpio_bit, GPIO_OUTPUT_PP);
+			gpio_write_bit(PIN_MAP[PA12].gpio_device, PIN_MAP[PA12].gpio_bit,0);
+			
+			for(volatile unsigned int i=0;i<512;i++);// Only small delay seems to be needed, and USB pins will get configured in Serial.begin
+			gpio_set_mode(PIN_MAP[PA12].gpio_device, PIN_MAP[PA12].gpio_bit, GPIO_INPUT_FLOATING);
+#endif			
+			Serial.begin();// Roger Clark. Changed SerialUSB to Serial for Arduino sketch compatibility
+#endif
+		}
+
+        __weak void series_init(void) {
+            // Initialize AFIO here, too, so peripheral remaps and external
+            // interrupts work out of the box.
+            afio_init();
+        }
+
+    }
+}
diff --git a/STM32F1/variants/generic_gd32f103c2/wirish/start.S b/STM32F1/variants/generic_gd32f103c2/wirish/start.S
new file mode 100644
index 0000000..a04f222
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f103c2/wirish/start.S
@@ -0,0 +1,57 @@
+/******************************************************************************
+ * The MIT License
+ *
+ * Copyright (c) 2011 LeafLabs, LLC.
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation
+ * files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy,
+ * modify, merge, publish, distribute, sublicense, and/or sell copies
+ * of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *****************************************************************************/
+
+/*
+ * This file is a modified version of a file obtained from
+ * CodeSourcery Inc. (now part of Mentor Graphics Corp.), in which the
+ * following text appeared:
+ *
+ * The authors hereby grant permission to use, copy, modify, distribute,
+ * and license this software and its documentation for any purpose, provided
+ * that existing copyright notices are retained in all copies and that this
+ * notice is included verbatim in any distributions. No written agreement,
+ * license, or royalty fee is required for any of the authorized uses.
+ * Modifications to this software may be copyrighted by their authors
+ * and need not follow the licensing terms described here, provided that
+ * the new terms are clearly indicated on the first page of each file where
+ * they apply.
+ */
+
+        .text
+        .code 16
+        .thumb_func
+
+        .globl __start__
+        .type __start__, %function
+__start__:
+        .fnstart
+        ldr r1,=__msp_init
+        mov sp,r1
+        ldr r1,=start_c
+        bx r1
+        .pool
+        .cantunwind
+        .fnend
diff --git a/STM32F1/variants/generic_gd32f103c2/wirish/start_c.c b/STM32F1/variants/generic_gd32f103c2/wirish/start_c.c
new file mode 100644
index 0000000..aa50018
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f103c2/wirish/start_c.c
@@ -0,0 +1,89 @@
+/******************************************************************************
+ * The MIT License
+ *
+ * Copyright (c) 2011 LeafLabs, LLC.
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation
+ * files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy,
+ * modify, merge, publish, distribute, sublicense, and/or sell copies
+ * of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *****************************************************************************/
+
+/*
+ * This file is a modified version of a file obtained from
+ * CodeSourcery Inc. (now part of Mentor Graphics Corp.), in which the
+ * following text appeared:
+ *
+ * Copyright (c) 2006, 2007 CodeSourcery Inc
+ *
+ * The authors hereby grant permission to use, copy, modify, distribute,
+ * and license this software and its documentation for any purpose, provided
+ * that existing copyright notices are retained in all copies and that this
+ * notice is included verbatim in any distributions. No written agreement,
+ * license, or royalty fee is required for any of the authorized uses.
+ * Modifications to this software may be copyrighted by their authors
+ * and need not follow the licensing terms described here, provided that
+ * the new terms are clearly indicated on the first page of each file where
+ * they apply.
+ */
+
+#include <stddef.h>
+
+extern void __libc_init_array(void);
+
+extern int main(int, char**, char**);
+
+/* The linker must ensure that these are at least 4-byte aligned. */
+extern char __data_start__, __data_end__;
+extern char __bss_start__, __bss_end__;
+
+struct rom_img_cfg {
+    int *img_start;
+};
+
+extern char _lm_rom_img_cfgp;
+
+void __attribute__((noreturn)) start_c(void) {
+    struct rom_img_cfg *img_cfg = (struct rom_img_cfg*)&_lm_rom_img_cfgp;
+    int *src = img_cfg->img_start;
+    int *dst = (int*)&__data_start__;
+
+    /* Initialize .data, if necessary. */
+    if (src != dst) {
+        int *end = (int*)&__data_end__;
+        while (dst < end) {
+            *dst++ = *src++;
+        }
+    }
+
+    /* Zero .bss. */
+    dst = (int*)&__bss_start__;
+    while (dst < (int*)&__bss_end__) {
+        *dst++ = 0;
+    }
+
+    /* Run initializers. */
+    __libc_init_array();
+
+    /* Jump to main. */
+    main(0, 0, 0);
+
+    /* If exit is NULL, make sure we don't return. */
+    for (;;)
+        continue;
+}
diff --git a/STM32F1/variants/generic_gd32f103c2/wirish/syscalls.c b/STM32F1/variants/generic_gd32f103c2/wirish/syscalls.c
new file mode 100644
index 0000000..ad878cb
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f103c2/wirish/syscalls.c
@@ -0,0 +1,176 @@
+/******************************************************************************
+ * The MIT License
+ *
+ * Copyright (c) 2010 Perry Hung.
+ * Copyright (c) 2011, 2012 LeafLabs, LLC.
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation
+ * files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy,
+ * modify, merge, publish, distribute, sublicense, and/or sell copies
+ * of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *****************************************************************************/
+
+/**
+ * @file wirish/syscalls.c
+ * @brief newlib stubs
+ *
+ * Low level system routines used by newlib for basic I/O and memory
+ * allocation. You can override most of these.
+ */
+
+#include <libmaple/libmaple.h>
+
+#include <sys/stat.h>
+#include <errno.h>
+#include <stddef.h>
+
+/* If CONFIG_HEAP_START (or CONFIG_HEAP_END) isn't defined, then
+ * assume _lm_heap_start (resp. _lm_heap_end) is appropriately set by
+ * the linker */
+#ifndef CONFIG_HEAP_START
+extern char _lm_heap_start;
+#define CONFIG_HEAP_START               ((void *)&_lm_heap_start)
+#endif
+#ifndef CONFIG_HEAP_END
+extern char _lm_heap_end;
+#define CONFIG_HEAP_END                 ((void *)&_lm_heap_end)
+#endif
+
+/*
+ * _sbrk -- Increment the program break.
+ *
+ * Get incr bytes more RAM (for use by the heap).  malloc() and
+ * friends call this function behind the scenes.
+ */
+void *_sbrk(int incr) {
+    static void * pbreak = NULL; /* current program break */
+    void * ret;
+
+    if (pbreak == NULL) {
+        pbreak = CONFIG_HEAP_START;
+    }
+
+    if ((CONFIG_HEAP_END - pbreak < incr) ||
+        (pbreak - CONFIG_HEAP_START < -incr)) {
+        errno = ENOMEM;
+        return (void *)-1;
+    }
+
+    ret = pbreak;
+    pbreak += incr;
+    return ret;
+}
+
+__weak int _open(const char *path __attribute__((unused)), int flags __attribute__((unused)), ...) {
+    return 1;
+}
+
+__weak int _close(int fd __attribute__((unused))) {
+    return 0;
+}
+
+__weak int _fstat(int fd __attribute__((unused)), struct stat *st) {
+    st->st_mode = S_IFCHR;
+    return 0;
+}
+
+__weak int _isatty(int fd __attribute__((unused))) {
+    return 1;
+}
+
+__weak int isatty(int fd __attribute__((unused))) {
+    return 1;
+}
+
+__weak int _lseek(int fd __attribute__((unused)), off_t pos __attribute__((unused)), int whence __attribute__((unused))) {
+    return -1;
+}
+
+__weak unsigned char getch(void) {
+    return 0;
+}
+
+
+__weak int _read(int fd __attribute__((unused)), char *buf, size_t cnt __attribute__((unused))) {
+    *buf = getch();
+
+    return 1;
+}
+
+__weak void putch(unsigned char c __attribute__((unused))) {
+}
+
+__weak void cgets(char *s, int bufsize) {
+    char *p;
+    int c;
+    int i;
+
+    for (i = 0; i < bufsize; i++) {
+        *(s+i) = 0;
+    }
+//    memset(s, 0, bufsize);
+
+    p = s;
+
+    for (p = s; p < s + bufsize-1;) {
+        c = getch();
+        switch (c) {
+        case '\r' :
+        case '\n' :
+            putch('\r');
+            putch('\n');
+            *p = '\n';
+            return;
+
+        case '\b' :
+            if (p > s) {
+                *p-- = 0;
+                putch('\b');
+                putch(' ');
+                putch('\b');
+            }
+            break;
+
+        default :
+            putch(c);
+            *p++ = c;
+            break;
+        }
+    }
+    return;
+}
+
+__weak int _write(int fd __attribute__((unused)), const char *buf, size_t cnt) {
+    size_t i;
+
+    for (i = 0; i < cnt; i++)
+        putch(buf[i]);
+
+    return cnt;
+}
+
+/* Override fgets() in newlib with a version that does line editing */
+__weak char *fgets(char *s, int bufsize, void *f __attribute__((unused))) {
+    cgets(s, bufsize);
+    return s;
+}
+
+__weak void _exit(int exitcode __attribute__((unused))) {
+    while (1)
+        ;
+}
diff --git a/STM32F1/variants/generic_gd32f303c/board.cpp b/STM32F1/variants/generic_gd32f303c/board.cpp
new file mode 100644
index 0000000..900e118
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f303c/board.cpp
@@ -0,0 +1,129 @@
+/******************************************************************************
+ * The MIT License
+ *
+ * Copyright (c) 2011 LeafLabs, LLC.
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation
+ * files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy,
+ * modify, merge, publish, distribute, sublicense, and/or sell copies
+ * of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *****************************************************************************/
+
+/**
+ * &file   wirish/boards/maple_mini/board.cpp
+ * &author Marti Bolivar <mbolivar&leaflabs.com>
+ * &brief  Maple Mini board file.
+ */
+
+#include <board/board.h>
+
+#include <libmaple/gpio.h>
+#include <libmaple/timer.h>
+
+/* Roger Clark. Added next to includes for changes to Serial */
+#include <libmaple/usart.h>
+#include <HardwareSerial.h>
+
+#include <wirish_debug.h>
+#include <wirish_types.h>
+
+/* Since we want the Serial Wire/JTAG pins as GPIOs, disable both SW
+ * and JTAG debug support, unless configured otherwise. */
+void boardInit(void) {
+#ifndef CONFIG_MAPLE_MINI_NO_DISABLE_DEBUG
+    disableDebugPorts();
+#endif
+}
+
+// Note. See the enum of pin names in board.h
+
+extern const stm32_pin_info PIN_MAP[BOARD_NR_GPIO_PINS] = {
+
+
+    {&gpioa, &timer2, &adc1,  0, 1,    0}, /* PA0 */
+    {&gpioa, &timer2, &adc1,  1, 2,    1}, /* PA1 */
+    {&gpioa, &timer2, &adc1,  2, 3,    2}, /* PA2 */	
+    {&gpioa, &timer2, &adc1,  3, 4,    3}, /* PA3 */
+    {&gpioa,   NULL, &adc1,  4, 0,    4}, /* PA4 */
+    {&gpioa,   NULL, &adc1,  5, 0,    5}, /* PA5 */
+    {&gpioa, &timer3, &adc1,  6, 1,    6}, /* PA6 */
+    {&gpioa, &timer3, &adc1,  7, 2,    7}, /* PA7 */
+    {&gpioa, &timer1, NULL,  8, 1, ADCx}, /* PA8 */	
+    {&gpioa, &timer1, NULL,  9, 2, ADCx}, /* PA9 */	
+    {&gpioa, &timer1, NULL, 10, 3, ADCx}, /* PA10 */
+    {&gpioa, &timer1, NULL, 11, 4, ADCx}, /* PA11 */
+    {&gpioa,   NULL, NULL, 12, 0, ADCx}, /* PA12 */	
+    {&gpioa,   NULL, NULL, 13, 0, ADCx}, /* PA13 */	
+    {&gpioa,   NULL, NULL, 14, 0, ADCx}, /* PA14 */
+    {&gpioa,   NULL, NULL, 15, 0, ADCx}, /* PA15 */
+	
+    {&gpiob, &timer3, &adc1,  0, 3,    8}, /* PB0 */	
+    {&gpiob, &timer3, &adc1,  1, 4,    9}, /* PB1 */
+    {&gpiob,   NULL, NULL,  2, 0, ADCx}, /* PB2 */
+    {&gpiob,   NULL, NULL,  3, 0, ADCx}, /* PB3 */
+    {&gpiob,   NULL, NULL,  4, 0, ADCx}, /* PB4 */
+    {&gpiob,   NULL, NULL,  5, 0, ADCx}, /* PB5 */
+    {&gpiob, &timer4, NULL,  6, 1, ADCx}, /* PB6 */
+    {&gpiob, &timer4, NULL,  7, 2, ADCx}, /* PB7 */	
+    {&gpiob, &timer4, NULL,  8, 3, ADCx}, /* PB8 */	
+    {&gpiob, &timer4, NULL,  9, 4, ADCx}, /* PB9 */	
+    {&gpiob,   NULL, NULL, 10, 0, ADCx}, /* PB10 */	
+    {&gpiob,   NULL, NULL, 11, 0, ADCx}, /* PB11 */
+    {&gpiob,   NULL, NULL, 12, 0, ADCx}, /* PB12 */
+    {&gpiob,   NULL, NULL, 13, 0, ADCx}, /* PB13 */
+    {&gpiob,   NULL, NULL, 14, 0, ADCx}, /* PB14 */
+    {&gpiob,   NULL, NULL, 15, 0, ADCx}, /* PB15 */
+
+    {&gpioc,   NULL, NULL, 13, 0, ADCx}, /* PC13 */	
+    {&gpioc,   NULL, NULL, 14, 0, ADCx}, /* PC14 */
+    {&gpioc,   NULL, NULL, 15, 0, ADCx}, /* PC15 */
+
+
+
+};
+
+extern const uint8 boardPWMPins[BOARD_NR_PWM_PINS] __FLASH__ = {
+    PB0, PA7, PA6, PA3, PA2, PA1, PA0, PB7, PB6, PA10, PA9, PA8
+};
+
+extern const uint8 boardADCPins[BOARD_NR_ADC_PINS] __FLASH__ = {
+    PB0, PA7, PA6 , PA5 , PA4 , PA3 , PA2 , PA1 , PA0 
+};
+
+// Note. These defines are not really used by generic boards. They are for  Maple Serial USB
+#define USB_DP PA12
+#define USB_DM PA11
+
+// NOte. These definitions are not really used for generic boards, they only relate to boards modified to behave like Maple boards
+extern const uint8 boardUsedPins[BOARD_NR_USED_PINS] __FLASH__ = {
+     USB_DP, USB_DM
+};
+
+
+/* 
+ * Roger Clark
+ * 
+ * 2015/05/28
+ *
+ * Moved definitions for Hardware Serial devices from HardwareSerial.cpp so that each board can define which Arduino "Serial" instance
+ * Maps to which hardware serial port on the microprocessor
+ */
+						
+DEFINE_HWSERIAL(Serial1, 1);
+DEFINE_HWSERIAL(Serial2, 2);
+DEFINE_HWSERIAL(Serial3, 3);
diff --git a/STM32F1/variants/generic_gd32f303c/board/board.h b/STM32F1/variants/generic_gd32f303c/board/board.h
new file mode 100644
index 0000000..e9451d6
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f303c/board/board.h
@@ -0,0 +1,90 @@
+/******************************************************************************
+ * The MIT License
+ *
+ * Copyright (c) 2011 LeafLabs, LLC.
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation
+ * files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy,
+ * modify, merge, publish, distribute, sublicense, and/or sell copies
+ * of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *****************************************************************************/
+
+/**
+ * @file   wirish/boards/maple_mini/include/board/board.h
+ * @author Marti Bolivar <mbolivar@leaflabs.com>
+ * @brief  Maple Mini board header.
+ *
+ * See wirish/boards/maple/include/board/board.h for more information
+ * on these definitions.
+ */
+
+#ifndef _BOARD_GENERIC_STM32F103C_H_
+#define _BOARD_GENERIC_STM32F103C_H_
+
+#define CYCLES_PER_MICROSECOND	(F_CPU / 1000000U)
+#define SYSTICK_RELOAD_VAL     (F_CPU/1000) - 1 /* takes a cycle to reload */
+
+#define BOARD_NR_USARTS           3
+#define BOARD_USART1_TX_PIN       PA9
+#define BOARD_USART1_RX_PIN       PA10
+#define BOARD_USART2_TX_PIN       PA2
+#define BOARD_USART2_RX_PIN       PA3
+#define BOARD_USART3_TX_PIN       PB10
+#define BOARD_USART3_RX_PIN       PB11
+
+#define BOARD_NR_SPI              2
+#define BOARD_SPI1_NSS_PIN        PA4
+#define BOARD_SPI1_MOSI_PIN       PA7
+#define BOARD_SPI1_MISO_PIN       PA6
+#define BOARD_SPI1_SCK_PIN        PA5
+
+#define BOARD_SPI1_ALT_NSS_PIN    PA15
+#define BOARD_SPI1_ALT_MOSI_PIN   PB5
+#define BOARD_SPI1_ALT_MISO_PIN   PB4
+#define BOARD_SPI1_ALT_SCK_PIN    PB3
+
+#define BOARD_SPI2_NSS_PIN        PB12
+#define BOARD_SPI2_MOSI_PIN       PB15
+#define BOARD_SPI2_MISO_PIN       PB14
+#define BOARD_SPI2_SCK_PIN        PB13
+
+#define BOARD_NR_GPIO_PINS        35
+#define BOARD_NR_PWM_PINS         12
+#define BOARD_NR_ADC_PINS          9
+#define BOARD_NR_USED_PINS         4
+
+
+#define BOARD_JTMS_SWDIO_PIN      22
+#define BOARD_JTCK_SWCLK_PIN      21
+#define BOARD_JTDI_PIN            20
+#define BOARD_JTDO_PIN            19
+#define BOARD_NJTRST_PIN          18
+
+#define BOARD_USB_DISC_DEV        NULL
+#define BOARD_USB_DISC_BIT        NULL
+
+#define LED_BUILTIN PC13
+
+// Note this needs to match with the PIN_MAP array in board.cpp
+enum {
+    PA0, PA1, PA2, PA3, PA4, PA5, PA6, PA7, PA8, PA9, PA10, PA11, PA12, PA13,PA14,PA15,
+	PB0, PB1, PB2, PB3, PB4, PB5, PB6, PB7, PB8, PB9, PB10, PB11, PB12, PB13,PB14,PB15,
+	PC13, PC14,PC15
+};
+
+#endif
diff --git a/STM32F1/variants/generic_gd32f303c/ld/bootloader_20.ld b/STM32F1/variants/generic_gd32f303c/ld/bootloader_20.ld
new file mode 100644
index 0000000..052915c
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f303c/ld/bootloader_20.ld
@@ -0,0 +1,30 @@
+/*
+ * libmaple linker script for "Flash" builds.
+ *
+ * A Flash build puts .text (and .rodata) in Flash, and
+ * .data/.bss/heap (of course) in SRAM, but offsets the sections by
+ * enough space to store the Maple bootloader, which lives in low
+ * Flash and uses low memory.
+ */
+
+/*
+ * This pulls in the appropriate MEMORY declaration from the right
+ * subdirectory of stm32/mem/ (the environment must call ld with the
+ * right include directory flags to make this happen). Boards can also
+ * use this file to use any of libmaple's memory-related hooks (like
+ * where the heap should live).
+ */
+MEMORY
+{
+  ram (rwx) : ORIGIN = 0x20000000, LENGTH = 48K
+  rom (rx)  : ORIGIN = 0x08002000, LENGTH = 248K
+}
+
+/* Provide memory region aliases for common.inc */
+REGION_ALIAS("REGION_TEXT", rom);
+REGION_ALIAS("REGION_DATA", ram);
+REGION_ALIAS("REGION_BSS", ram);
+REGION_ALIAS("REGION_RODATA", rom);
+
+/* Let common.inc handle the real work. */
+INCLUDE common.inc
diff --git a/STM32F1/variants/generic_gd32f303c/ld/bootloader_20_c6.ld b/STM32F1/variants/generic_gd32f303c/ld/bootloader_20_c6.ld
new file mode 100755
index 0000000..499efcc
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f303c/ld/bootloader_20_c6.ld
@@ -0,0 +1,30 @@
+/*
+ * libmaple linker script for "Flash" builds.
+ *
+ * A Flash build puts .text (and .rodata) in Flash, and
+ * .data/.bss/heap (of course) in SRAM, but offsets the sections by
+ * enough space to store the Maple bootloader, which lives in low
+ * Flash and uses low memory.
+ */
+
+/*
+ * This pulls in the appropriate MEMORY declaration from the right
+ * subdirectory of stm32/mem/ (the environment must call ld with the
+ * right include directory flags to make this happen). Boards can also
+ * use this file to use any of libmaple's memory-related hooks (like
+ * where the heap should live).
+ */
+MEMORY
+{
+  ram (rwx) : ORIGIN = 0x20000000, LENGTH = 10K
+  rom (rx)  : ORIGIN = 0x08002000, LENGTH = 24K
+}
+
+/* Provide memory region aliases for common.inc */
+REGION_ALIAS("REGION_TEXT", rom);
+REGION_ALIAS("REGION_DATA", ram);
+REGION_ALIAS("REGION_BSS", ram);
+REGION_ALIAS("REGION_RODATA", rom);
+
+/* Let common.inc handle the real work. */
+INCLUDE common.inc
diff --git a/STM32F1/variants/generic_gd32f303c/ld/common.inc b/STM32F1/variants/generic_gd32f303c/ld/common.inc
new file mode 100644
index 0000000..0c2b6a4
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f303c/ld/common.inc
@@ -0,0 +1,220 @@
+/*
+ * Linker script for libmaple.
+ *
+ * Original author "lanchon" from ST forums, with modifications by LeafLabs.
+ */
+
+OUTPUT_FORMAT ("elf32-littlearm", "elf32-bigarm", "elf32-littlearm")
+
+/*
+ * Configure other libraries we want in the link.
+ *
+ * libgcc, libc, and libm are common across supported toolchains.
+ * However, some toolchains require additional archives which aren't
+ * present everywhere (e.g. ARM's gcc-arm-embedded releases).
+ *
+ * To hack around this, we let the build system specify additional
+ * archives by putting the right extra_libs.inc (in a directory under
+ * toolchains/) in our search path.
+ */
+GROUP(libgcc.a libc.a libm.a)
+INCLUDE extra_libs.inc
+
+/*
+ * These force the linker to search for vector table symbols.
+ *
+ * These symbols vary by STM32 family (and also within families).
+ * It's up to the build system to configure the link's search path
+ * properly for the target MCU.
+ */
+INCLUDE vector_symbols.inc
+
+/* STM32 vector table. */
+EXTERN(__stm32_vector_table)
+
+/* C runtime initialization function. */
+EXTERN(start_c)
+
+/* main entry point */
+EXTERN(main)
+
+/* Initial stack pointer value. */
+EXTERN(__msp_init)
+PROVIDE(__msp_init = ORIGIN(ram) + LENGTH(ram));
+
+/* Reset vector and chip reset entry point */
+EXTERN(__start__)
+ENTRY(__start__)
+PROVIDE(__exc_reset = __start__);
+
+/* Heap boundaries, for libmaple */
+EXTERN(_lm_heap_start);
+EXTERN(_lm_heap_end);
+
+SECTIONS
+{
+    .text :
+      {
+        __text_start__ = .;
+        /*
+         * STM32 vector table.  Leave this here.  Yes, really.
+         */
+        *(.stm32.interrupt_vector)
+
+        /*
+         * Program code and vague linking
+         */
+        *(.text .text.* .gnu.linkonce.t.*)
+        *(.plt)
+        *(.gnu.warning)
+        *(.glue_7t) *(.glue_7) *(.vfp11_veneer)
+
+        *(.ARM.extab* .gnu.linkonce.armextab.*)
+        *(.gcc_except_table)
+        *(.eh_frame_hdr)
+        *(.eh_frame)
+
+        . = ALIGN(4);
+        KEEP(*(.init))
+
+        . = ALIGN(4);
+        __preinit_array_start = .;
+        KEEP (*(.preinit_array))
+        __preinit_array_end = .;
+
+        . = ALIGN(4);
+        __init_array_start = .;
+        KEEP (*(SORT(.init_array.*)))
+        KEEP (*(.init_array))
+        __init_array_end = .;
+
+        . = ALIGN(0x4);
+        KEEP (*crtbegin.o(.ctors))
+        KEEP (*(EXCLUDE_FILE (*crtend.o) .ctors))
+        KEEP (*(SORT(.ctors.*)))
+        KEEP (*crtend.o(.ctors))
+
+        . = ALIGN(4);
+        KEEP(*(.fini))
+
+        . = ALIGN(4);
+        __fini_array_start = .;
+        KEEP (*(.fini_array))
+        KEEP (*(SORT(.fini_array.*)))
+        __fini_array_end = .;
+
+        KEEP (*crtbegin.o(.dtors))
+        KEEP (*(EXCLUDE_FILE (*crtend.o) .dtors))
+        KEEP (*(SORT(.dtors.*)))
+        KEEP (*crtend.o(.dtors))
+      } > REGION_TEXT
+
+    /*
+     * End of text
+     */
+    .text.align :
+      {
+        . = ALIGN(8);
+        __text_end__ = .;
+      } > REGION_TEXT
+
+    /*
+     * .ARM.exidx exception unwinding; mandated by ARM's C++ ABI
+     */
+    __exidx_start = .;
+    .ARM.exidx :
+      {
+        *(.ARM.exidx* .gnu.linkonce.armexidx.*)
+      } > REGION_RODATA
+    __exidx_end = .;
+
+    /*
+     * .data
+     */
+    .data :
+      {
+        __data_start__ = .;
+      	LONG(0)
+        . = ALIGN(8);
+
+        *(.got.plt) *(.got)
+        *(.data .data.* .gnu.linkonce.d.*)
+
+        . = ALIGN(8);
+        __data_end__ = .;
+      } > REGION_DATA AT> REGION_RODATA
+
+    /*
+     * Read-only data
+     */
+    .rodata :
+      {
+        *(.rodata .rodata.* .gnu.linkonce.r.*)
+        /* .USER_FLASH: We allow users to allocate into Flash here */
+        *(.USER_FLASH)
+        /* ROM image configuration; for C startup */
+        . = ALIGN(4);
+        _lm_rom_img_cfgp = .;
+        LONG(LOADADDR(.data));
+        /*
+         * Heap: Linker scripts may choose a custom heap by overriding
+         * _lm_heap_start and _lm_heap_end. Otherwise, the heap is in
+         * internal SRAM, beginning after .bss, and growing towards
+         * the stack.
+         *
+         * I'm shoving these here naively; there's probably a cleaner way
+         * to go about this. [mbolivar]
+         */
+        _lm_heap_start = DEFINED(_lm_heap_start) ? _lm_heap_start : _end;
+        _lm_heap_end   = DEFINED(_lm_heap_end) ? _lm_heap_end : __msp_init;
+      } > REGION_RODATA
+
+    /*
+     * .bss
+     */
+    .bss :
+      {
+        . = ALIGN(8);
+        __bss_start__ = .;
+        *(.bss .bss.* .gnu.linkonce.b.*)
+        *(COMMON)
+        . = ALIGN (8);
+        __bss_end__ = .;
+        _end = __bss_end__;
+      } > REGION_BSS
+
+    /*
+     * Debugging sections
+     */
+    .stab 0 (NOLOAD) : { *(.stab) }
+    .stabstr 0 (NOLOAD) : { *(.stabstr) }
+    /* DWARF debug sections.
+     * Symbols in the DWARF debugging sections are relative to the beginning
+     * of the section so we begin them at 0.  */
+    /* DWARF 1 */
+    .debug          0 : { *(.debug) }
+    .line           0 : { *(.line) }
+    /* GNU DWARF 1 extensions */
+    .debug_srcinfo  0 : { *(.debug_srcinfo) }
+    .debug_sfnames  0 : { *(.debug_sfnames) }
+    /* DWARF 1.1 and DWARF 2 */
+    .debug_aranges  0 : { *(.debug_aranges) }
+    .debug_pubnames 0 : { *(.debug_pubnames) }
+    /* DWARF 2 */
+    .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }
+    .debug_abbrev   0 : { *(.debug_abbrev) }
+    .debug_line     0 : { *(.debug_line) }
+    .debug_frame    0 : { *(.debug_frame) }
+    .debug_str      0 : { *(.debug_str) }
+    .debug_loc      0 : { *(.debug_loc) }
+    .debug_macinfo  0 : { *(.debug_macinfo) }
+    /* SGI/MIPS DWARF 2 extensions */
+    .debug_weaknames 0 : { *(.debug_weaknames) }
+    .debug_funcnames 0 : { *(.debug_funcnames) }
+    .debug_typenames 0 : { *(.debug_typenames) }
+    .debug_varnames  0 : { *(.debug_varnames) }
+
+    .note.gnu.arm.ident 0 : { KEEP (*(.note.gnu.arm.ident)) }
+    .ARM.attributes 0 : { KEEP (*(.ARM.attributes)) }
+    /DISCARD/ : { *(.note.GNU-stack) }
+}
diff --git a/STM32F1/variants/generic_gd32f303c/ld/extra_libs.inc b/STM32F1/variants/generic_gd32f303c/ld/extra_libs.inc
new file mode 100644
index 0000000..4413a53
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f303c/ld/extra_libs.inc
@@ -0,0 +1,7 @@
+/*
+ * Extra archives needed by ARM's GCC ARM Embedded arm-none-eabi-
+ * releases (https://launchpad.net/gcc-arm-embedded/).
+ */
+
+/* This is for the provided newlib. */
+GROUP(libnosys.a)
diff --git a/STM32F1/variants/generic_gd32f303c/ld/flash.ld b/STM32F1/variants/generic_gd32f303c/ld/flash.ld
new file mode 100644
index 0000000..38a3023
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f303c/ld/flash.ld
@@ -0,0 +1,26 @@
+/*
+ * libmaple linker script for "Flash" builds.
+ *
+ * A Flash build puts .text (and .rodata) in Flash, and
+ * .data/.bss/heap (of course) in SRAM, but offsets the sections by
+ * enough space to store the Maple bootloader, which lives in low
+ * Flash and uses low memory.
+ */
+
+/*
+ * This pulls in the appropriate MEMORY declaration from the right
+ * subdirectory of stm32/mem/ (the environment must call ld with the
+ * right include directory flags to make this happen). Boards can also
+ * use this file to use any of libmaple's memory-related hooks (like
+ * where the heap should live).
+ */
+INCLUDE mem-flash.inc
+
+/* Provide memory region aliases for common.inc */
+REGION_ALIAS("REGION_TEXT", rom);
+REGION_ALIAS("REGION_DATA", ram);
+REGION_ALIAS("REGION_BSS", ram);
+REGION_ALIAS("REGION_RODATA", rom);
+
+/* Let common.inc handle the real work. */
+INCLUDE common.inc
diff --git a/STM32F1/variants/generic_gd32f303c/ld/flash_c8.ld b/STM32F1/variants/generic_gd32f303c/ld/flash_c8.ld
new file mode 100644
index 0000000..2a35550
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f303c/ld/flash_c8.ld
@@ -0,0 +1,33 @@
+/*
+ * libmaple linker script for "Flash" builds.
+ *
+ * A Flash build puts .text (and .rodata) in Flash, and
+ * .data/.bss/heap (of course) in SRAM, but offsets the sections by
+ * enough space to store the Maple bootloader, which lives in low
+ * Flash and uses low memory.
+ */
+
+/*
+ * This pulls in the appropriate MEMORY declaration from the right
+ * subdirectory of stm32/mem/ (the environment must call ld with the
+ * right include directory flags to make this happen). Boards can also
+ * use this file to use any of libmaple's memory-related hooks (like
+ * where the heap should live).
+ */
+/*INCLUDE mem-flash.inc*/
+
+MEMORY
+{
+  ram (rwx) : ORIGIN = 0x20000C00, LENGTH = 17K
+  rom (rx)  : ORIGIN = 0x08000000, LENGTH = 44K
+}
+
+
+/* Provide memory region aliases for common.inc */
+REGION_ALIAS("REGION_TEXT", rom);
+REGION_ALIAS("REGION_DATA", ram);
+REGION_ALIAS("REGION_BSS", ram);
+REGION_ALIAS("REGION_RODATA", rom);
+
+/* Let common.inc handle the real work. */
+INCLUDE common.inc
diff --git a/STM32F1/variants/generic_gd32f303c/ld/hid_bootloader.ld b/STM32F1/variants/generic_gd32f303c/ld/hid_bootloader.ld
new file mode 100644
index 0000000..d5b1f06
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f303c/ld/hid_bootloader.ld
@@ -0,0 +1,30 @@
+/*
+ * libmaple linker script for "Flash" builds.
+ *
+ * A Flash build puts .text (and .rodata) in Flash, and
+ * .data/.bss/heap (of course) in SRAM, but offsets the sections by
+ * enough space to store the Maple bootloader, which lives in low
+ * Flash and uses low memory.
+ */
+
+/*
+ * This pulls in the appropriate MEMORY declaration from the right
+ * subdirectory of stm32/mem/ (the environment must call ld with the
+ * right include directory flags to make this happen). Boards can also
+ * use this file to use any of libmaple's memory-related hooks (like
+ * where the heap should live).
+ */
+MEMORY
+{
+  ram (rwx) : ORIGIN = 0x20000000, LENGTH = 20K
+  rom (rx)  : ORIGIN = 0x08001000, LENGTH = 124K
+}
+
+/* Provide memory region aliases for common.inc */
+REGION_ALIAS("REGION_TEXT", rom);
+REGION_ALIAS("REGION_DATA", ram);
+REGION_ALIAS("REGION_BSS", ram);
+REGION_ALIAS("REGION_RODATA", rom);
+
+/* Let common.inc handle the real work. */
+INCLUDE common.inc
diff --git a/STM32F1/variants/generic_gd32f303c/ld/hid_bootloader_c6.ld b/STM32F1/variants/generic_gd32f303c/ld/hid_bootloader_c6.ld
new file mode 100644
index 0000000..e758192
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f303c/ld/hid_bootloader_c6.ld
@@ -0,0 +1,30 @@
+/*
+ * libmaple linker script for "Flash" builds.
+ *
+ * A Flash build puts .text (and .rodata) in Flash, and
+ * .data/.bss/heap (of course) in SRAM, but offsets the sections by
+ * enough space to store the Maple bootloader, which lives in low
+ * Flash and uses low memory.
+ */
+
+/*
+ * This pulls in the appropriate MEMORY declaration from the right
+ * subdirectory of stm32/mem/ (the environment must call ld with the
+ * right include directory flags to make this happen). Boards can also
+ * use this file to use any of libmaple's memory-related hooks (like
+ * where the heap should live).
+ */
+MEMORY
+{
+  ram (rwx) : ORIGIN = 0x20000000, LENGTH = 10K
+  rom (rx)  : ORIGIN = 0x08001000, LENGTH = 24K
+}
+
+/* Provide memory region aliases for common.inc */
+REGION_ALIAS("REGION_TEXT", rom);
+REGION_ALIAS("REGION_DATA", ram);
+REGION_ALIAS("REGION_BSS", ram);
+REGION_ALIAS("REGION_RODATA", rom);
+
+/* Let common.inc handle the real work. */
+INCLUDE common.inc
diff --git a/STM32F1/variants/generic_gd32f303c/ld/jtag.ld b/STM32F1/variants/generic_gd32f303c/ld/jtag.ld
new file mode 100644
index 0000000..62ae052
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f303c/ld/jtag.ld
@@ -0,0 +1,31 @@
+/*
+ * libmaple linker script for "JTAG" builds.
+ *
+ * A "JTAG" build puts .text (and .rodata) in Flash, and
+ * .data/.bss/heap (of course) in SRAM, but links starting at the
+ * Flash and SRAM starting addresses (0x08000000 and 0x20000000
+ * respectively). This will wipe out a Maple bootloader if there's one
+ * on the board, so only use this if you know what you're doing.
+ *
+ * Of course, a "JTAG" build is perfectly usable for upload over SWD,
+ * the system memory bootloader, etc. The name is just a historical
+ * artifact.
+ */
+
+/*
+ * This pulls in the appropriate MEMORY declaration from the right
+ * subdirectory of stm32/mem/ (the environment must call ld with the
+ * right include directory flags to make this happen). Boards can also
+ * use this file to use any of libmaple's memory-related hooks (like
+ * where the heap should live).
+ */
+INCLUDE mem-jtag.inc
+
+/* Provide memory region aliases for common.inc */
+REGION_ALIAS("REGION_TEXT", rom);
+REGION_ALIAS("REGION_DATA", ram);
+REGION_ALIAS("REGION_BSS", ram);
+REGION_ALIAS("REGION_RODATA", rom);
+
+/* Let common.inc handle the real work. */
+INCLUDE common.inc
diff --git a/STM32F1/variants/generic_gd32f303c/ld/jtag_c6.ld b/STM32F1/variants/generic_gd32f303c/ld/jtag_c6.ld
new file mode 100644
index 0000000..1684795
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f303c/ld/jtag_c6.ld
@@ -0,0 +1,36 @@
+/*
+ * libmaple linker script for "JTAG" builds.
+ *
+ * A "JTAG" build puts .text (and .rodata) in Flash, and
+ * .data/.bss/heap (of course) in SRAM, but links starting at the
+ * Flash and SRAM starting addresses (0x08000000 and 0x20000000
+ * respectively). This will wipe out a Maple bootloader if there's one
+ * on the board, so only use this if you know what you're doing.
+ *
+ * Of course, a "JTAG" build is perfectly usable for upload over SWD,
+ * the system memory bootloader, etc. The name is just a historical
+ * artifact.
+ */
+
+/*
+ * This pulls in the appropriate MEMORY declaration from the right
+ * subdirectory of stm32/mem/ (the environment must call ld with the
+ * right include directory flags to make this happen). Boards can also
+ * use this file to use any of libmaple's memory-related hooks (like
+ * where the heap should live).
+ */
+
+MEMORY
+{
+  ram (rwx) : ORIGIN = 0x20000000, LENGTH = 10K
+  rom (rx)  : ORIGIN = 0x08000000, LENGTH = 32K
+}
+
+/* Provide memory region aliases for common.inc */
+REGION_ALIAS("REGION_TEXT", rom);
+REGION_ALIAS("REGION_DATA", ram);
+REGION_ALIAS("REGION_BSS", ram);
+REGION_ALIAS("REGION_RODATA", rom);
+
+/* Let common.inc handle the real work. */
+INCLUDE common.inc
diff --git a/STM32F1/variants/generic_gd32f303c/ld/jtag_c8.ld b/STM32F1/variants/generic_gd32f303c/ld/jtag_c8.ld
new file mode 100644
index 0000000..2e01979
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f303c/ld/jtag_c8.ld
@@ -0,0 +1,36 @@
+/*
+ * libmaple linker script for "JTAG" builds.
+ *
+ * A "JTAG" build puts .text (and .rodata) in Flash, and
+ * .data/.bss/heap (of course) in SRAM, but links starting at the
+ * Flash and SRAM starting addresses (0x08000000 and 0x20000000
+ * respectively). This will wipe out a Maple bootloader if there's one
+ * on the board, so only use this if you know what you're doing.
+ *
+ * Of course, a "JTAG" build is perfectly usable for upload over SWD,
+ * the system memory bootloader, etc. The name is just a historical
+ * artifact.
+ */
+
+/*
+ * This pulls in the appropriate MEMORY declaration from the right
+ * subdirectory of stm32/mem/ (the environment must call ld with the
+ * right include directory flags to make this happen). Boards can also
+ * use this file to use any of libmaple's memory-related hooks (like
+ * where the heap should live).
+ */
+
+MEMORY
+{
+  ram (rwx) : ORIGIN = 0x20000000, LENGTH = 48K
+  rom (rx)  : ORIGIN = 0x08000000, LENGTH = 256K
+}
+
+/* Provide memory region aliases for common.inc */
+REGION_ALIAS("REGION_TEXT", rom);
+REGION_ALIAS("REGION_DATA", ram);
+REGION_ALIAS("REGION_BSS", ram);
+REGION_ALIAS("REGION_RODATA", rom);
+
+/* Let common.inc handle the real work. */
+INCLUDE common.inc
diff --git a/STM32F1/variants/generic_gd32f303c/ld/mem-flash.inc b/STM32F1/variants/generic_gd32f303c/ld/mem-flash.inc
new file mode 100644
index 0000000..1a9c32e
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f303c/ld/mem-flash.inc
@@ -0,0 +1,5 @@
+MEMORY
+{
+  ram (rwx) : ORIGIN = 0x20000C00, LENGTH = 45K
+  rom (rx)  : ORIGIN = 0x08005000, LENGTH = 236K
+}
diff --git a/STM32F1/variants/generic_gd32f303c/ld/mem-jtag.inc b/STM32F1/variants/generic_gd32f303c/ld/mem-jtag.inc
new file mode 100644
index 0000000..ca2756d
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f303c/ld/mem-jtag.inc
@@ -0,0 +1,5 @@
+MEMORY
+{
+  ram (rwx) : ORIGIN = 0x20000000, LENGTH = 48K
+  rom (rx)  : ORIGIN = 0x08000000, LENGTH = 256K
+}
diff --git a/STM32F1/variants/generic_gd32f303c/ld/mem-ram.inc b/STM32F1/variants/generic_gd32f303c/ld/mem-ram.inc
new file mode 100644
index 0000000..dc6d329
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f303c/ld/mem-ram.inc
@@ -0,0 +1,5 @@
+MEMORY
+{
+  ram (rwx) : ORIGIN = 0x20000C00, LENGTH = 17K
+  rom (rx)  : ORIGIN = 0x08005000, LENGTH = 0K
+}
diff --git a/STM32F1/variants/generic_gd32f303c/ld/ram.ld b/STM32F1/variants/generic_gd32f303c/ld/ram.ld
new file mode 100644
index 0000000..1ea7598
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f303c/ld/ram.ld
@@ -0,0 +1,25 @@
+/*
+ * libmaple linker script for RAM builds.
+ *
+ * A Flash build puts .text, .rodata, and .data/.bss/heap (of course)
+ * in SRAM, but offsets the sections by enough space to store the
+ * Maple bootloader, which uses low memory.
+ */
+
+/*
+ * This pulls in the appropriate MEMORY declaration from the right
+ * subdirectory of stm32/mem/ (the environment must call ld with the
+ * right include directory flags to make this happen). Boards can also
+ * use this file to use any of libmaple's memory-related hooks (like
+ * where the heap should live).
+ */
+INCLUDE mem-ram.inc
+
+/* Provide memory region aliases for common.inc */
+REGION_ALIAS("REGION_TEXT", ram);
+REGION_ALIAS("REGION_DATA", ram);
+REGION_ALIAS("REGION_BSS", ram);
+REGION_ALIAS("REGION_RODATA", ram);
+
+/* Let common.inc handle the real work. */
+INCLUDE common.inc
diff --git a/STM32F1/variants/generic_gd32f303c/ld/ram_c8.ld b/STM32F1/variants/generic_gd32f303c/ld/ram_c8.ld
new file mode 100644
index 0000000..9f9f6bb
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f303c/ld/ram_c8.ld
@@ -0,0 +1,31 @@
+/*
+ * libmaple linker script for RAM builds.
+ *
+ * A Flash build puts .text, .rodata, and .data/.bss/heap (of course)
+ * in SRAM, but offsets the sections by enough space to store the
+ * Maple bootloader, which uses low memory.
+ */
+
+/*
+ * This pulls in the appropriate MEMORY declaration from the right
+ * subdirectory of stm32/mem/ (the environment must call ld with the
+ * right include directory flags to make this happen). Boards can also
+ * use this file to use any of libmaple's memory-related hooks (like
+ * where the heap should live).
+ */
+/*INCLUDE mem-ram.inc*/
+MEMORY
+{
+  ram (rwx) : ORIGIN = 0x20000C00, LENGTH = 17K
+  rom (rx)  : ORIGIN = 0x08005000, LENGTH = 0
+}
+
+
+/* Provide memory region aliases for common.inc */
+REGION_ALIAS("REGION_TEXT", ram);
+REGION_ALIAS("REGION_DATA", ram);
+REGION_ALIAS("REGION_BSS", ram);
+REGION_ALIAS("REGION_RODATA", ram);
+
+/* Let common.inc handle the real work. */
+INCLUDE common.inc
diff --git a/STM32F1/variants/generic_gd32f303c/ld/vector_symbols.inc b/STM32F1/variants/generic_gd32f303c/ld/vector_symbols.inc
new file mode 100644
index 0000000..a40012a
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f303c/ld/vector_symbols.inc
@@ -0,0 +1,78 @@
+EXTERN(__msp_init)
+EXTERN(__exc_reset)
+EXTERN(__exc_nmi)
+EXTERN(__exc_hardfault)
+EXTERN(__exc_memmanage)
+EXTERN(__exc_busfault)
+EXTERN(__exc_usagefault)
+EXTERN(__stm32reservedexception7)
+EXTERN(__stm32reservedexception8)
+EXTERN(__stm32reservedexception9)
+EXTERN(__stm32reservedexception10)
+EXTERN(__exc_svc)
+EXTERN(__exc_debug_monitor)
+EXTERN(__stm32reservedexception13)
+EXTERN(__exc_pendsv)
+EXTERN(__exc_systick)
+
+EXTERN(__irq_wwdg)
+EXTERN(__irq_pvd)
+EXTERN(__irq_tamper)
+EXTERN(__irq_rtc)
+EXTERN(__irq_flash)
+EXTERN(__irq_rcc)
+EXTERN(__irq_exti0)
+EXTERN(__irq_exti1)
+EXTERN(__irq_exti2)
+EXTERN(__irq_exti3)
+EXTERN(__irq_exti4)
+EXTERN(__irq_dma1_channel1)
+EXTERN(__irq_dma1_channel2)
+EXTERN(__irq_dma1_channel3)
+EXTERN(__irq_dma1_channel4)
+EXTERN(__irq_dma1_channel5)
+EXTERN(__irq_dma1_channel6)
+EXTERN(__irq_dma1_channel7)
+EXTERN(__irq_adc)
+EXTERN(__irq_usb_hp_can_tx)
+EXTERN(__irq_usb_lp_can_rx0)
+EXTERN(__irq_can_rx1)
+EXTERN(__irq_can_sce)
+EXTERN(__irq_exti9_5)
+EXTERN(__irq_tim1_brk)
+EXTERN(__irq_tim1_up)
+EXTERN(__irq_tim1_trg_com)
+EXTERN(__irq_tim1_cc)
+EXTERN(__irq_tim2)
+EXTERN(__irq_tim3)
+EXTERN(__irq_tim4)
+EXTERN(__irq_i2c1_ev)
+EXTERN(__irq_i2c1_er)
+EXTERN(__irq_i2c2_ev)
+EXTERN(__irq_i2c2_er)
+EXTERN(__irq_spi1)
+EXTERN(__irq_spi2)
+EXTERN(__irq_usart1)
+EXTERN(__irq_usart2)
+EXTERN(__irq_usart3)
+EXTERN(__irq_exti15_10)
+EXTERN(__irq_rtcalarm)
+EXTERN(__irq_usbwakeup)
+
+EXTERN(__irq_tim8_brk)
+EXTERN(__irq_tim8_up)
+EXTERN(__irq_tim8_trg_com)
+EXTERN(__irq_tim8_cc)
+EXTERN(__irq_adc3)
+EXTERN(__irq_fsmc)
+EXTERN(__irq_sdio)
+EXTERN(__irq_tim5)
+EXTERN(__irq_spi3)
+EXTERN(__irq_uart4)
+EXTERN(__irq_uart5)
+EXTERN(__irq_tim6)
+EXTERN(__irq_tim7)
+EXTERN(__irq_dma2_channel1)
+EXTERN(__irq_dma2_channel2)
+EXTERN(__irq_dma2_channel3)
+EXTERN(__irq_dma2_channel4_5)
diff --git a/STM32F1/variants/generic_gd32f303c/pins_arduino.h b/STM32F1/variants/generic_gd32f303c/pins_arduino.h
new file mode 100644
index 0000000..d7518e6
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f303c/pins_arduino.h
@@ -0,0 +1,6 @@
+
+
+
+
+// API compatibility
+#include "variant.h"
\ No newline at end of file
diff --git a/STM32F1/variants/generic_gd32f303c/variant.h b/STM32F1/variants/generic_gd32f303c/variant.h
new file mode 100644
index 0000000..dc4b894
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f303c/variant.h
@@ -0,0 +1,22 @@
+#ifndef _VARIANT_ARDUINO_STM32_
+#define _VARIANT_ARDUINO_STM32_
+
+#define digitalPinToPort(P)        ( PIN_MAP[P].gpio_device )
+#define digitalPinToBitMask(P)     ( BIT(PIN_MAP[P].gpio_bit) )
+#define portOutputRegister(port)   ( &(port->regs->ODR) )
+#define portInputRegister(port)    ( &(port->regs->IDR) )
+
+#define portSetRegister(pin)		( &(PIN_MAP[pin].gpio_device->regs->BSRR) )
+#define portClearRegister(pin)		( &(PIN_MAP[pin].gpio_device->regs->BRR) )
+
+#define portConfigRegister(pin)		( &(PIN_MAP[pin].gpio_device->regs->CRL) )
+
+static const uint8_t SS   = BOARD_SPI1_NSS_PIN;
+static const uint8_t SS1  = BOARD_SPI2_NSS_PIN;
+static const uint8_t MOSI = BOARD_SPI1_MOSI_PIN;
+static const uint8_t MISO = BOARD_SPI1_MISO_PIN;
+static const uint8_t SCK  = BOARD_SPI1_SCK_PIN;
+
+#define LED_BUILTIN PC13
+
+#endif /* _VARIANT_ARDUINO_STM32_ */
diff --git a/STM32F1/variants/generic_gd32f303c/wirish/boards.cpp b/STM32F1/variants/generic_gd32f303c/wirish/boards.cpp
new file mode 100644
index 0000000..53f3469
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f303c/wirish/boards.cpp
@@ -0,0 +1,225 @@
+/******************************************************************************
+ * The MIT License
+ *
+ * Copyright (c) 2010 Perry Hung.
+ * Copyright (c) 2011, 2012 LeafLabs, LLC.
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation
+ * files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy,
+ * modify, merge, publish, distribute, sublicense, and/or sell copies
+ * of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *****************************************************************************/
+
+/**
+ * @file wirish/boards.cpp
+ * @brief init() and board routines.
+ *
+ * This file is mostly interesting for the init() function, which
+ * configures Flash, the core clocks, and a variety of other available
+ * peripherals on the board so the rest of Wirish doesn't have to turn
+ * things on before using them.
+ *
+ * Prior to returning, init() calls boardInit(), which allows boards
+ * to perform any initialization they need to. This file includes a
+ * weak no-op definition of boardInit(), so boards that don't need any
+ * special initialization don't have to define their own.
+ *
+ * How init() works is chip-specific. See the boards_setup.cpp files
+ * under e.g. wirish/stm32f1/, wirish/stmf32f2 for the details, but be
+ * advised: their contents are unstable, and can/will change without
+ * notice.
+ */
+
+#include <boards.h>
+#include <libmaple/libmaple_types.h>
+#include <libmaple/flash.h>
+#include <libmaple/nvic.h>
+#include <libmaple/systick.h>
+#include "boards_private.h"
+
+static void setup_flash(void);
+static void setup_clocks(void);
+static void setup_nvic(void);
+static void setup_adcs(void);
+static void setup_timers(void);
+
+/*
+ * Exported functions
+ */
+
+void init(void) {
+    setup_flash();
+    setup_clocks();
+    setup_nvic();
+    systick_init(SYSTICK_RELOAD_VAL);
+    wirish::priv::board_setup_gpio();
+    setup_adcs();
+    setup_timers();
+    wirish::priv::board_setup_usb();
+    wirish::priv::series_init();
+    boardInit();
+}
+
+/* Provide a default no-op boardInit(). */
+__weak void boardInit(void) {
+}
+
+/* You could farm this out to the files in boards/ if e.g. it takes
+ * too long to test on boards with lots of pins. */
+bool boardUsesPin(uint8 pin) {
+    for (int i = 0; i < BOARD_NR_USED_PINS; i++) {
+        if (pin == boardUsedPins[i]) {
+            return true;
+        }
+    }
+    return false;
+}
+
+/*
+ * Auxiliary routines
+ */
+
+static void setup_flash(void) {
+    // Turn on as many Flash "go faster" features as
+    // possible. flash_enable_features() just ignores any flags it
+    // can't support.
+    flash_enable_features(FLASH_PREFETCH | FLASH_ICACHE | FLASH_DCACHE);
+    // Configure the wait states, assuming we're operating at "close
+    // enough" to 3.3V.
+    flash_set_latency(FLASH_SAFE_WAIT_STATES);
+}
+
+static void setup_clocks(void) {
+    // Turn on HSI. We'll switch to and run off of this while we're
+    // setting up the main PLL.
+    rcc_turn_on_clk(RCC_CLK_HSI);
+
+    // Turn off and reset the clock subsystems we'll be using, as well
+    // as the clock security subsystem (CSS). Note that resetting CFGR
+    // to its default value of 0 implies a switch to HSI for SYSCLK.
+    RCC_BASE->CFGR = 0x00000000;
+    rcc_disable_css();
+    rcc_turn_off_clk(RCC_CLK_PLL);
+    rcc_turn_off_clk(RCC_CLK_HSE);
+    wirish::priv::board_reset_pll();
+    // Clear clock readiness interrupt flags and turn off clock
+    // readiness interrupts.
+    RCC_BASE->CIR = 0x00000000;
+#if !USE_HSI_CLOCK
+    // Enable HSE, and wait until it's ready.
+    rcc_turn_on_clk(RCC_CLK_HSE);
+    while (!rcc_is_clk_ready(RCC_CLK_HSE))
+        ;
+#endif
+    // Configure AHBx, APBx, etc. prescalers and the main PLL.
+    wirish::priv::board_setup_clock_prescalers();
+    rcc_configure_pll(&wirish::priv::w_board_pll_cfg);
+
+    // Enable the PLL, and wait until it's ready.
+    rcc_turn_on_clk(RCC_CLK_PLL);
+    while(!rcc_is_clk_ready(RCC_CLK_PLL))
+        ;
+
+    // Finally, switch to the now-ready PLL as the main clock source.
+    rcc_switch_sysclk(RCC_CLKSRC_PLL);
+}
+
+/*
+ * These addresses are where usercode starts when a bootloader is
+ * present. If no bootloader is present, the user NVIC usually starts
+ * at the Flash base address, 0x08000000.
+ */
+#if defined(BOOTLOADER_maple)
+	#define USER_ADDR_ROM 0x08005000
+#else
+	#define USER_ADDR_ROM 0x08000000
+#endif
+#define USER_ADDR_RAM 0x20000C00
+extern char __text_start__;
+
+static void setup_nvic(void) {
+
+nvic_init((uint32)VECT_TAB_ADDR, 0);
+
+/* Roger Clark. We now control nvic vector table in boards.txt using the build.vect paramater
+#ifdef VECT_TAB_FLASH
+    nvic_init(USER_ADDR_ROM, 0);
+#elif defined VECT_TAB_RAM
+    nvic_init(USER_ADDR_RAM, 0);
+#elif defined VECT_TAB_BASE
+    nvic_init((uint32)0x08000000, 0);
+#elif defined VECT_TAB_ADDR
+    // A numerically supplied value
+    nvic_init((uint32)VECT_TAB_ADDR, 0);
+#else
+    // Use the __text_start__ value from the linker script; this
+    // should be the start of the vector table.
+    nvic_init((uint32)&__text_start__, 0);
+#endif
+
+*/
+}
+
+static void adc_default_config( adc_dev *dev) {
+    adc_enable_single_swstart(dev);
+    adc_set_sample_rate(dev, wirish::priv::w_adc_smp);
+}
+
+static void setup_adcs(void) {
+    adc_set_prescaler(wirish::priv::w_adc_pre);
+    adc_foreach(adc_default_config);
+}
+
+static void timer_default_config(timer_dev *dev) {
+    timer_adv_reg_map *regs = (dev->regs).adv;
+    const uint16 full_overflow = 0xFFFF;
+    const uint16 half_duty = 0x8FFF;
+
+    timer_init(dev);
+    timer_pause(dev);
+
+    regs->CR1 = TIMER_CR1_ARPE;
+    regs->PSC = 1;
+    regs->SR = 0;
+    regs->DIER = 0;
+    regs->EGR = TIMER_EGR_UG;
+    switch (dev->type) {
+    case TIMER_ADVANCED:
+        regs->BDTR = TIMER_BDTR_MOE | TIMER_BDTR_LOCK_OFF;
+        // fall-through
+    case TIMER_GENERAL:
+        timer_set_reload(dev, full_overflow);
+        for (uint8 channel = 1; channel <= 4; channel++) {
+            if (timer_has_cc_channel(dev, channel)) {
+                timer_set_compare(dev, channel, half_duty);
+                timer_oc_set_mode(dev, channel, TIMER_OC_MODE_PWM_1,
+                                  TIMER_OC_PE);
+            }
+        }
+        // fall-through
+    case TIMER_BASIC:
+        break;
+    }
+
+    timer_generate_update(dev);
+    timer_resume(dev);
+}
+
+static void setup_timers(void) {
+    timer_foreach(timer_default_config);
+}
diff --git a/STM32F1/variants/generic_gd32f303c/wirish/boards_setup.cpp b/STM32F1/variants/generic_gd32f303c/wirish/boards_setup.cpp
new file mode 100644
index 0000000..102099f
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f303c/wirish/boards_setup.cpp
@@ -0,0 +1,129 @@
+/******************************************************************************
+ * The MIT License
+ *
+ * Copyright (c) 2012 LeafLabs, LLC.
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation
+ * files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy,
+ * modify, merge, publish, distribute, sublicense, and/or sell copies
+ * of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+*****************************************************************************/
+
+/**
+ * @file wirish/stm32f1/boards_setup.cpp
+ * @author Marti Bolivar <mbolivar@leaflabs.com>
+ * @brief STM32F1 chip setup.
+ *
+ * This file controls how init() behaves on the STM32F1. Be very
+ * careful when changing anything here. Many of these values depend
+ * upon each other.
+ */
+
+#include "boards_private.h"
+
+#include <libmaple/gpio.h>
+#include <libmaple/timer.h>
+
+#include <boards.h>
+#include <usb_serial.h>
+
+// Allow boards to provide a PLL multiplier. This is useful for
+// e.g. STM32F100 value line MCUs, which use slower multipliers.
+// (We're leaving the default to RCC_PLLMUL_9 for now, since that
+// works for F103 performance line MCUs, which is all that LeafLabs
+// currently officially supports).
+
+// MEANX : We use a 8 Mhz Xtal !
+
+#ifndef BOARD_RCC_PLLMUL
+  #if !USE_HSI_CLOCK
+	#if F_CPU==120000000
+		#define BOARD_RCC_PLLMUL RCC_PLLMUL_14 // stay below 120 Mhz, 14*8=112
+    #elif F_CPU==96000000
+	    #define BOARD_RCC_PLLMUL RCC_PLLMUL_12 // 12*8=96 Mhz
+	#elif F_CPU==72000000
+		#define BOARD_RCC_PLLMUL RCC_PLLMUL_9
+	#elif F_CPU==48000000
+		#define BOARD_RCC_PLLMUL RCC_PLLMUL_6
+	#elif F_CPU==16000000
+		#define BOARD_RCC_PLLMUL RCC_PLLMUL_2
+	#endif
+  #else
+	#define BOARD_RCC_PLLMUL RCC_PLLMUL_16
+  #endif
+#endif
+
+namespace wirish {
+    namespace priv {
+
+        static stm32f1_rcc_pll_data pll_data = {BOARD_RCC_PLLMUL};
+#if !USE_HSI_CLOCK
+        __weak rcc_pll_cfg w_board_pll_cfg = {RCC_PLLSRC_HSE, &pll_data};
+#else
+        __weak rcc_pll_cfg w_board_pll_cfg = {RCC_PLLSRC_HSI_DIV_2, &pll_data};
+#endif
+        __weak adc_prescaler w_adc_pre = ADC_PRE_PCLK2_DIV_6;
+        __weak adc_smp_rate w_adc_smp = ADC_SMPR_55_5;
+
+        __weak void board_reset_pll(void) {
+            // TODO
+        }
+// 48 Mhz USB Clock
+        __weak void board_setup_clock_prescalers(void) {
+            rcc_set_prescaler(RCC_PRESCALER_AHB, RCC_AHB_SYSCLK_DIV_1);
+            rcc_set_prescaler(RCC_PRESCALER_APB1, RCC_APB1_HCLK_DIV_2);
+            rcc_set_prescaler(RCC_PRESCALER_APB2, RCC_APB2_HCLK_DIV_1);
+			rcc_clk_disable(RCC_USB);
+	        #if F_CPU == 120000000
+			rcc_set_prescaler(RCC_PRESCALER_USB, RCC_USB_SYSCLK_DIV_2_5);
+		#elif F_CPU == 96000000
+			rcc_set_prescaler(RCC_PRESCALER_USB, RCC_USB_SYSCLK_DIV_2);
+                #elif F_CPU == 72000000
+			rcc_set_prescaler(RCC_PRESCALER_USB, RCC_USB_SYSCLK_DIV_1_5);
+                #elif F_CPU == 48000000
+			rcc_set_prescaler(RCC_PRESCALER_USB, RCC_USB_SYSCLK_DIV_1);			
+                #endif	
+        }
+
+        __weak void board_setup_gpio(void) {
+            gpio_init_all();
+        }
+
+        __weak void board_setup_usb(void) {
+#ifdef SERIAL_USB
+			
+#ifdef GENERIC_BOOTLOADER			
+			//Reset the USB interface on generic boards - developed by Victor PV
+			gpio_set_mode(PIN_MAP[PA12].gpio_device, PIN_MAP[PA12].gpio_bit, GPIO_OUTPUT_PP);
+			gpio_write_bit(PIN_MAP[PA12].gpio_device, PIN_MAP[PA12].gpio_bit,0);
+			
+			for(volatile unsigned int i=0;i<512;i++);// Only small delay seems to be needed, and USB pins will get configured in Serial.begin
+			gpio_set_mode(PIN_MAP[PA12].gpio_device, PIN_MAP[PA12].gpio_bit, GPIO_INPUT_FLOATING);
+#endif			
+			Serial.begin();// Roger Clark. Changed SerialUSB to Serial for Arduino sketch compatibility
+#endif
+		}
+
+        __weak void series_init(void) {
+            // Initialize AFIO here, too, so peripheral remaps and external
+            // interrupts work out of the box.
+            afio_init();
+        }
+
+    }
+}
diff --git a/STM32F1/variants/generic_gd32f303c/wirish/start.S b/STM32F1/variants/generic_gd32f303c/wirish/start.S
new file mode 100644
index 0000000..a04f222
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f303c/wirish/start.S
@@ -0,0 +1,57 @@
+/******************************************************************************
+ * The MIT License
+ *
+ * Copyright (c) 2011 LeafLabs, LLC.
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation
+ * files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy,
+ * modify, merge, publish, distribute, sublicense, and/or sell copies
+ * of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *****************************************************************************/
+
+/*
+ * This file is a modified version of a file obtained from
+ * CodeSourcery Inc. (now part of Mentor Graphics Corp.), in which the
+ * following text appeared:
+ *
+ * The authors hereby grant permission to use, copy, modify, distribute,
+ * and license this software and its documentation for any purpose, provided
+ * that existing copyright notices are retained in all copies and that this
+ * notice is included verbatim in any distributions. No written agreement,
+ * license, or royalty fee is required for any of the authorized uses.
+ * Modifications to this software may be copyrighted by their authors
+ * and need not follow the licensing terms described here, provided that
+ * the new terms are clearly indicated on the first page of each file where
+ * they apply.
+ */
+
+        .text
+        .code 16
+        .thumb_func
+
+        .globl __start__
+        .type __start__, %function
+__start__:
+        .fnstart
+        ldr r1,=__msp_init
+        mov sp,r1
+        ldr r1,=start_c
+        bx r1
+        .pool
+        .cantunwind
+        .fnend
diff --git a/STM32F1/variants/generic_gd32f303c/wirish/start_c.c b/STM32F1/variants/generic_gd32f303c/wirish/start_c.c
new file mode 100644
index 0000000..aa50018
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f303c/wirish/start_c.c
@@ -0,0 +1,89 @@
+/******************************************************************************
+ * The MIT License
+ *
+ * Copyright (c) 2011 LeafLabs, LLC.
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation
+ * files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy,
+ * modify, merge, publish, distribute, sublicense, and/or sell copies
+ * of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *****************************************************************************/
+
+/*
+ * This file is a modified version of a file obtained from
+ * CodeSourcery Inc. (now part of Mentor Graphics Corp.), in which the
+ * following text appeared:
+ *
+ * Copyright (c) 2006, 2007 CodeSourcery Inc
+ *
+ * The authors hereby grant permission to use, copy, modify, distribute,
+ * and license this software and its documentation for any purpose, provided
+ * that existing copyright notices are retained in all copies and that this
+ * notice is included verbatim in any distributions. No written agreement,
+ * license, or royalty fee is required for any of the authorized uses.
+ * Modifications to this software may be copyrighted by their authors
+ * and need not follow the licensing terms described here, provided that
+ * the new terms are clearly indicated on the first page of each file where
+ * they apply.
+ */
+
+#include <stddef.h>
+
+extern void __libc_init_array(void);
+
+extern int main(int, char**, char**);
+
+/* The linker must ensure that these are at least 4-byte aligned. */
+extern char __data_start__, __data_end__;
+extern char __bss_start__, __bss_end__;
+
+struct rom_img_cfg {
+    int *img_start;
+};
+
+extern char _lm_rom_img_cfgp;
+
+void __attribute__((noreturn)) start_c(void) {
+    struct rom_img_cfg *img_cfg = (struct rom_img_cfg*)&_lm_rom_img_cfgp;
+    int *src = img_cfg->img_start;
+    int *dst = (int*)&__data_start__;
+
+    /* Initialize .data, if necessary. */
+    if (src != dst) {
+        int *end = (int*)&__data_end__;
+        while (dst < end) {
+            *dst++ = *src++;
+        }
+    }
+
+    /* Zero .bss. */
+    dst = (int*)&__bss_start__;
+    while (dst < (int*)&__bss_end__) {
+        *dst++ = 0;
+    }
+
+    /* Run initializers. */
+    __libc_init_array();
+
+    /* Jump to main. */
+    main(0, 0, 0);
+
+    /* If exit is NULL, make sure we don't return. */
+    for (;;)
+        continue;
+}
diff --git a/STM32F1/variants/generic_gd32f303c/wirish/syscalls.c b/STM32F1/variants/generic_gd32f303c/wirish/syscalls.c
new file mode 100644
index 0000000..ad878cb
--- /dev/null
+++ b/STM32F1/variants/generic_gd32f303c/wirish/syscalls.c
@@ -0,0 +1,176 @@
+/******************************************************************************
+ * The MIT License
+ *
+ * Copyright (c) 2010 Perry Hung.
+ * Copyright (c) 2011, 2012 LeafLabs, LLC.
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation
+ * files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy,
+ * modify, merge, publish, distribute, sublicense, and/or sell copies
+ * of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *****************************************************************************/
+
+/**
+ * @file wirish/syscalls.c
+ * @brief newlib stubs
+ *
+ * Low level system routines used by newlib for basic I/O and memory
+ * allocation. You can override most of these.
+ */
+
+#include <libmaple/libmaple.h>
+
+#include <sys/stat.h>
+#include <errno.h>
+#include <stddef.h>
+
+/* If CONFIG_HEAP_START (or CONFIG_HEAP_END) isn't defined, then
+ * assume _lm_heap_start (resp. _lm_heap_end) is appropriately set by
+ * the linker */
+#ifndef CONFIG_HEAP_START
+extern char _lm_heap_start;
+#define CONFIG_HEAP_START               ((void *)&_lm_heap_start)
+#endif
+#ifndef CONFIG_HEAP_END
+extern char _lm_heap_end;
+#define CONFIG_HEAP_END                 ((void *)&_lm_heap_end)
+#endif
+
+/*
+ * _sbrk -- Increment the program break.
+ *
+ * Get incr bytes more RAM (for use by the heap).  malloc() and
+ * friends call this function behind the scenes.
+ */
+void *_sbrk(int incr) {
+    static void * pbreak = NULL; /* current program break */
+    void * ret;
+
+    if (pbreak == NULL) {
+        pbreak = CONFIG_HEAP_START;
+    }
+
+    if ((CONFIG_HEAP_END - pbreak < incr) ||
+        (pbreak - CONFIG_HEAP_START < -incr)) {
+        errno = ENOMEM;
+        return (void *)-1;
+    }
+
+    ret = pbreak;
+    pbreak += incr;
+    return ret;
+}
+
+__weak int _open(const char *path __attribute__((unused)), int flags __attribute__((unused)), ...) {
+    return 1;
+}
+
+__weak int _close(int fd __attribute__((unused))) {
+    return 0;
+}
+
+__weak int _fstat(int fd __attribute__((unused)), struct stat *st) {
+    st->st_mode = S_IFCHR;
+    return 0;
+}
+
+__weak int _isatty(int fd __attribute__((unused))) {
+    return 1;
+}
+
+__weak int isatty(int fd __attribute__((unused))) {
+    return 1;
+}
+
+__weak int _lseek(int fd __attribute__((unused)), off_t pos __attribute__((unused)), int whence __attribute__((unused))) {
+    return -1;
+}
+
+__weak unsigned char getch(void) {
+    return 0;
+}
+
+
+__weak int _read(int fd __attribute__((unused)), char *buf, size_t cnt __attribute__((unused))) {
+    *buf = getch();
+
+    return 1;
+}
+
+__weak void putch(unsigned char c __attribute__((unused))) {
+}
+
+__weak void cgets(char *s, int bufsize) {
+    char *p;
+    int c;
+    int i;
+
+    for (i = 0; i < bufsize; i++) {
+        *(s+i) = 0;
+    }
+//    memset(s, 0, bufsize);
+
+    p = s;
+
+    for (p = s; p < s + bufsize-1;) {
+        c = getch();
+        switch (c) {
+        case '\r' :
+        case '\n' :
+            putch('\r');
+            putch('\n');
+            *p = '\n';
+            return;
+
+        case '\b' :
+            if (p > s) {
+                *p-- = 0;
+                putch('\b');
+                putch(' ');
+                putch('\b');
+            }
+            break;
+
+        default :
+            putch(c);
+            *p++ = c;
+            break;
+        }
+    }
+    return;
+}
+
+__weak int _write(int fd __attribute__((unused)), const char *buf, size_t cnt) {
+    size_t i;
+
+    for (i = 0; i < cnt; i++)
+        putch(buf[i]);
+
+    return cnt;
+}
+
+/* Override fgets() in newlib with a version that does line editing */
+__weak char *fgets(char *s, int bufsize, void *f __attribute__((unused))) {
+    cgets(s, bufsize);
+    return s;
+}
+
+__weak void _exit(int exitcode __attribute__((unused))) {
+    while (1)
+        ;
+}
